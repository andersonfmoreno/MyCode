/*      NOTICE:
        THIS INFORMATION IS CONFIDENTIAL AND PROPRIETARY TO INTEC TELECOM
        SYSTEMS AND MAY NOT BE COPIED, MODIFIED, OR OTHERWISE USED.
;+
vivo_common_procedures.scr - VIVO Common Procedures

Autor:		Equipe Implementacao Intec

Funcao:		Contem procedimentos/funcoes comuns a outros scripts.

Compile line:	cgdc_compiler -v -debug -P $CGDC_DB_PATH/src/vivo_common_procedures.scr

Invocacao:	From DCS Operation Manager - Transform Class

$log
$log

 *******************************************************************************

Revision History:2010/05/26 11:11:01  rsato

Revision 1.44  2010/05/26 11:11:01  rsato
incluido rotina de tratamento do retorno no DPM

Revision 1.43  2009/12/22 11:11:01  rsato
incluido tratamento de arquivos contendo registros exportados do eps

$Log: vivo_common_procedures.scr,v $
Revision 1.42  2005/06/01 14:11:01  jcarvalh
alteracao no gestao de negocios do mcdr - joel em 01062005

Revision 1.41  2005/05/30 13:24:48  cokuyama
Funcoes para fornecer o numero sequencial do arquivo em hexadecimal alterada para retornar os valores em maiscula

Revision 1.40  2005/05/24 22:50:22  cgi
Alterado nome do arquivo de backup para incluir n. seq interno do Intermediate e data de coleta

Revision 1.38  2005/03/17 16:26:11  sfernand
Insercao de FILE_REGISTRY_ID para funcoes de IRPT de saida.

Revision 1.37  2005/02/22 14:42:17  sfernand
 *** empty log message ***

Revision 1.36  2005/02/22 14:38:38  sfernand
Inserida rotina nas procedures Irpt_GeraLogEntrada_VozDados e Irpt_GeraLogEntrada_Terceiros para se verificar se o registro vem do EPS. Nesse caso, nao se gera o log no DPM.

Revision 1.34  2005/02/03 23:03:57  sfernand
 *** empty log message ***

Revision 1.33  2005/01/27 19:19:28  asato
rotina DestCriticas, quando nao encontra pesquisa mais uma vez com 999 antes de retornar default

Revision 1.32  2004/10/14 14:00:58  jcarvalh
alteracao na procedure ValidaRegistroFcdr, descarte na duracao de atendimento <=3 segundos e no agrupamento na duracao tarifada

Revision 1.31  2004/09/24 21:28:39  sfernand
Inserido tratamento para RECUT nas funcoes Irpt_geraLogSaida_VozDados e Irpt_GeraLogSaida_Terceiros.

Revision 1.30  2004/09/20 18:58:01  sfernand
Funcoes Irpt_GeraLogEntrada alteradas: quando ArquivoEntrada for branco, usar o FileRegistryId.

Revision 1.29  2004/09/20 12:56:01  syamaki
 *** empty log message ***

Revision 1.28  2004/08/25 23:03:05  asato
 *** empty log message ***

Revision 1.27  2004/08/24 18:55:09  asato
 *** empty log message ***

Revision 1.26  2004/07/01 16:08:11  jcarvalh
Teste no enviado para EPS

Revision 1.25  2004/06/23 14:58:04  sfernand
Insercao de parametro sOperVisitada na funcao Irpt_SumarizaEntrada_Terceiros.

Revision 1.24  2004/06/15 15:44:16  sfernand
 *** empty log message ***

Revision 1.23  2004/06/14 13:48:01  sfernand
 *** empty log message ***

Revision 1.22  2004/06/14 13:41:21  sfernand
 *** empty log message ***

Revision 1.20  2004/06/14 13:07:35  syamaki
Insercao da consulta da tabela de criticas

Revision 1.19  2004/06/09 19:34:29  sfernand
 *** empty log message ***

Revision 1.18  2004/06/09 15:51:26  sfernand
Inclusao do File Registry Id nas procedures do IRPT.

Revision 1.17  2004/06/03 19:32:07  sfernand
Funcao Irpt_GetRegional alterada para buscar regional na tabela "vivo_tab_portal_central".

Revision 1.16  2004/06/03 16:06:33  sfernand
 *** empty log message ***

Revision 1.15  2004/05/19 19:29:31  sfernand
 *** empty log message ***

Revision 1.14  2004/05/04 20:12:29  asato
 *** empty log message ***

Revision 1.12  2004/05/04 13:38:19  asato
Correcao na rotina de pesquisa na tabela MIN_IFAST

Revision 1.11  2004/04/27 16:00:10  sfernand
Alterada variavel sDestino nas procedures Irpt_GeraLogSaida_VozDados e Irpt_GeraLogSaida_Terceiros.

Revision 1.10  2004/04/23 20:24:50  sfernand
 *** empty log message ***

Revision 1.9  2004/04/22 23:00:59  sfernand
Insercao da procedure GetPortalCCCinfo.

Revision 1.8  2004/04/22 21:21:04  syamaki
Inclusao Tratamento Mensagens EPS - DPM

Revision 1.7  2004/04/20 21:56:58  sfernand
 *** empty log message ***

Revision 1.6  2004/04/20 13:50:30  sfernand
Acrescimo do parametro sDataHoraEvento a funcao Irpt_SumarizaEntrada_Terceiros.

Revision 1.5  2004/04/19 21:37:47  sfernand
Insercao das funcoes Irpt_InicializaEntrada_VozDados e Irpt_SumarizaEntrada_VozDados e novo container para entrada voz/dados.

Revision 1.4  2004/04/12 18:45:32  sfernand
Inclusao da funcao Irpt_GetStringParams.

Revision 1.3  2004/04/06 20:21:10  sfernand
Inclusao do parametro 'sCodigoRejeicao' na funcao Irpt_SumarizaEntrada_Terceiros.

Revision 1.2  2004/03/26 20:47:17  sfernand
Procedure Irpt_GetRegional alterada para o caso de terceiros.

Revision 1.1  2004/03/26 20:29:38  sfernand
Initial revision

# Revision 1.29  2004/03/18  20:23:51  sfernand
# Funcoes antigas do DPM retiradas.
#
# Revision 1.28  2004/03/17  20:13:24  sfernand
# Inserted procedure Irpt_GetRegional.
#
# Revision 1.27  2004/03/15  21:50:31  sfernand
# *** empty log message ***
#
# Revision 1.26  2004/03/08  22:45:19  sfernand
# Insercao das funcoes do IRPT (Inter-mediatE Reporting) que geram logs atraves do DPM (Data Processing Message).
#
# Revision 1.24  2004/02/27  22:14:15  sfernand
# *** empty log message ***
#
# Revision 1.23  2004/02/27  20:30:02  sfernand
# Correcoes nas procedures de DPM (Data Processing Message).
#
# Revision 1.22  2004/02/27  13:10:34  cgi
# *** empty log message ***
#
# Revision 1.21  2004/02/19  13:24:18  jcarvalh
# Inserindo container da geracao dos relatorios de gestao de negocios
#
# Revision 1.20  2004/02/19  12:50:28  cgi
# *** empty log message ***
#
# Revision 1.19  2004/02/13  19:46:45  sfernand
# Re-inclusao da procedure isOperadoraVIVO.
#
# Revision 1.18  2004/02/13  19:41:43  cgi
# ajuste variavel iSegundos
#
# Revision 1.17  2004/02/13  17:38:31  cgi
# Inclusao procedures CarregaContainerInTer, CarregaContainerOutTer, DpmLogOutputTerceiros, DpmLogInputTerceiros
# InitializeScriptInTer, InitializeScriptOutTer
#
# Revision 1.16  2004/02/10  14:10:31  asato
# Correcao PadZeroEsq
#
# Revision 1.16  2004/02/10  14:10:31  asato
# Correcao PadZeroEsq
#
# Revision 1.15  2004/02/10  14:06:13  cgi
# retirada procedure CarregaContainerOutput sendo nao mais necessaria
#
# Revision 1.14  2004/02/09  20:46:39  cgi
# Inclusao de procedures CarregaContainerOutput e DpmLogOutput
#
# Revision 1.13  2004/02/09  14:02:13  cgi
# Alteracao na Tabela para saber a origem do arquivo processado
#
# Revision 1.12  2004/02/03  22:52:45  hbernal
# Atualizacao da rotina PadZeroEsq.
#
# Revision 1.11  2004/02/02  16:42:24  asato
# Atualizacao da rotina LookupTabPrefixosNac
#
# Revision 1.9  2004/01/26  16:39:12  asato
# inclusao da rotina isOperadoraVIVO
#
# Revision 1.8  2004/01/26  15:48:54  asato
# inclusao da rotina ConvHMSToSecs
#
# Revision 1.7  2004/01/23  18:56:43  asato
# inclusao da rotina GetParticaoPrefixoRJ
#
# Revision 1.6  2004/01/20  16:38:32  asato
# Inclusao da rotina PadZeroEsq e modificacao em LookupTabPrefixosNac
#
# Revision 1.5  2004/01/15  18:59:14  asato
# *** empty log message ***
#
# Revision 1.4  2004/01/15  18:33:10  asato
# *** empty log message ***
#
# Revision 1.3  2004/01/15  18:27:59  asato
# Inclusao de LookupTabPrefixosNac
#
# Revision 1.2  2004/01/14  22:37:02  syamaki
# First version
#
# Revision 1.15  2003/12/11  19:35:08  jcarvalh
# Gera informacoes CRT_MED para o Inter-mediatE Reporting
# Revision 1.15  2003/12/08  18:55:08  jcarvalh
# Gera informacoes de estatistica para o Inter-mediatE Reporting
#
# Revision 1.14  2003/12/05  20:52:14  sfernand
# GetCCCinfo corrigida.
#
# Revision 1.13  2003/12/04  14:35:43  sfernand
# Alteracao na procedure GetCCCinfo.
#
# Revision 1.12  2003/12/03  19:55:57  asato
# *** empty log message ***
#
# Revision 1.11  2003/12/03  19:48:11  asato
# procedure GetCCCcode modificada para GetCCCinfo, preenchendo varias informacoes a respeito da CCC
#
# Revision 1.10  2003/12/01  18:01:40  sfernand
# *** empty log message ***
#
# Revision 1.9  2003/12/01  15:56:44  sfernand
# Inclusao da procedure ConvSecsToHMS.
#
# Revision 1.8  2003/12/01  15:00:48  sfernand
# Inclusao da procedure GetCCCcode, criada por Armando Sato.
#
# Revision 1.7  2003/11/21  18:35:33  sfernand
# *** empty log message ***
#
# Revision 1.6  2003/11/21  18:12:56  sfernand
# *** empty log message ***
#
# Revision 1.5  2003/11/21  12:38:41  sfernand
# Inclusao da variavel sOriginalNumber na procedure LookupMinIfast.
#
# Revision 1.4  2003/11/14  20:06:59  sfernand
# Mudanca do registro de tab_min_ifast_rec para vivo_tab_min_ifast_rec.
#
# Revision 1.3  2003/11/14  18:51:47  sfernand
# Inclusao da procedure LookupTabMinIfast.
#
# Revision 1.1  2003/11/14  18:02:00  syamaki
# Initial revision
#
Revision 1.1  2003/03/28 20:08:31  cgi
Autor:		Joel Nunes de Carvalho
Funcao:		Gera relatorio para Gestao de Negocios
                utilizando os formatos FCDR,MCDR,TIDR e RSR

Descricoes dos registros:

Entrada:	vivo_fcdr 	- CDR's Formato Padrao
Saida:		vivo_gnfcdr  	- CDR's Formato para Gestao de Negocios

Entrada:	vivo_mcdr 	- CDR's Formato Padrao
Saida:		vivo_gnmcdr  	- CDR's Formato para Gestao de Negocios

Entrada:	vivo_tidr 	- CDR's Formato Padrao
Saida:		vivo_gntidr  	- CDR's Formato para Gestao de Negocios

Entrada:	vivo_rsr 	- CDR's Formato Padrao
Saida:		vivo_gnrsr  	- CDR's Formato para Gestao de Negocios

Historico:

1.0	Joel Nunes de Carvalho	- 	09/02/2004	- 	Criacao.
...
1.1	Luciano Sa				-	28/08/2008	- Criacao da procedure Irpt_SumarizaTransformacao_v2
										- Inclusao das procedures:
										InicializarVivoTabPortalCentral
										GetCentralFromTabPortalCentral
*    12/11/2008 Marcelo Baiao - SOFTFILE
		- Demanda: 15907 
		- Objetivo: Separação do tráfego gerado pela rede GSM na tabela GNFCDR

2.0	Joel Nunes de Carvalho	-	31/03/2009	-	Alteração na procedure "MakeOffset" para o corrigir o incidente 
								referente chamado nr.14522044, esta procedure estava gerando falha 
								quando não existia na o file_registry_id master na base do intermediate

3.0	Roberto Sato		-	01/06/2010	-	Inserção do ABORT em cada procdimento, para que caso ocorra falha na criação
								do dpm log este é abortado, retorna como falhado e recriado.								

4.0	Joel Nunes de Carvalho	-	22/06/2011	-	Patronização do file_registry_id em todas etapa para melhorar a performance na consulta do IRPT

5.0 Walter Fonseca	- 19/08/2013 - Chamado 20525185 - Correcao do campo correspondente ao total de bytes do irpt 

5.1 Rafael Reinoldes - 04/05/2015 - INC000000915502 - Correção da contabilização do GPRS, aumento do campo de sumarização
 ******************************************************************************
;-
 */

$$
#include <dcs_cgdc.h>	//Interface to DCS Operation Manager
$$

$$
#include <cgdc_conv.h>
$$

#include <dcs_dpm_api.h> //Interface to DPM functions

#include <vivo_utl_declare.h>


/* C O N S T A N T E S ********************************************************/

#define SECONDS_PER_MINUTE      60
#define SECONDS_PER_HOUR        (SECONDS_PER_MINUTE * 60)
#define MIN_PER_HOUR            60

#define TRUE                    1
#define FALSE                   0

#define DEBUG_LEVEL    0
#define TRACE(message)  \
        if(DEBUG_LEVEL == 1) debug (message);\
        if(DEBUG_LEVEL == 2)\
        {\
                debug_ctl("append","/tmp/cgdc_debug_vivo_selecao_kenan_fcdr");\
                debug (FORMAT("[%d@%s]:\t%s", $linenumber, $scriptname, message));\
                debug_ctl("close","/tmp/cgdc_debug_vivo_selecao_kenan_fcdr");\
        };

/* D E F I N I C O E S  G L O B A I S *****************************************/


//GNFCDR
declare static record "container"	rContainerFcdr;
declare static record "vivo_gnfcdr"	rGnFcdrRec;
declare static integer 			giContainerSizeFcdr;
//GNMCDR
declare static record "container"	rContainerMcdr;
declare static record "vivo_gnmcdr"	rGnMcdrRec;
declare static integer 			giContainerSizeMcdr;
//GNTIDR
declare static record "container"	rContainerTidr;
declare static record "vivo_gntidr"	rGnTidrRec;
declare static integer 			giContainerSizeTidr;
//GNRSR
declare static record "container"	rContainerRsr;
declare static record "vivo_gnrsr"	rGnRsrRec;
declare static integer 			giContainerSizeRsr;
//GNBilling
declare static record "container"		rContainerBilling;
declare static record "vivo_irpt_gnbilling"	rGnBillingRec;
declare static integer 				giContainerSizeBilling;

//Container usado para relatorios (IRPT) de dados de entrada (voz e dados)
declare static record "container"			rEntradaVozDadosHdl;
declare static record "vivo_irpt_entrada_voz_dados"	rEntradaVozDadosRec;
declare static integer					giEntradaVozDadosRecSize;

//Container usado para relatorios (IRPT) de dados de saida (voz e dados)
declare static record "container"			rSaidaVozDadosHdl;
declare static record "vivo_irpt_saida_voz_dados"	rSaidaVozDadosRec;
declare static integer					giSaidaVozDadosRecSize;

//Container usado para relatorios (IRPT) de dados de saida (Stage)
declare static record "container"			rSaidaStageHdl;
declare static record "vivo_irpt_saida_stage"	rSaidaStageRec;
declare static integer					giSaidaStageRecSize;

//Container usado para relatorios (IRPT) de dados de processos transformacao (voz, dados e terceiros)
declare static record "container"			rTransformacaoHdl;
declare static record "vivo_irpt_transformacao"		rTransformacaoRec;
declare static integer					giTransformacaoRecSize;

//Container usado para relatorios (IRPT) de dados de processos transformacao (voz, dados e terceiros - Stage)
declare static record "container"			rTransfStageHdl;
declare static record "vivo_irpt_transf_stage"		rTransfStageRec;
declare static integer					giTransfStageRecSize;

//Container usado para relatorios (IRPT) de dados de entrada (terceiros)
declare static record "container"			rEntradaTerceirosHdl;
declare static record "vivo_irpt_entrada_terceiros"	rEntradaTerceirosRec;
declare static integer					giEntradaTerceirosRecSize;

//Container usado para relatorios (IRPT) de dados de saida (voz e dados)
declare static record "container"			rSaidaTerceirosHdl;
declare static record "vivo_irpt_saida_terceiros"	rSaidaTerceirosRec;
declare static integer					giSaidaTerceirosRecSize;

//Variaveis usadas para IRPT em scripts de output de DRD
declare static string					gsEquipamentoEntrada;
declare static string					gsPortalEntrada;
declare static string					gsFileRegistryId;

//Tabela de Relacao Portal x Central, usada na funcao Irpt_GetRegional
declare static record "reference_table" 		hdl_PortalCentral;
declare static record "vivo_tab_portal_central_rec" 	rec_PortalCentral;

declare static integer					gTabcriticainit;
declare static record "vivo_tab_dest_criticas_rec"	rTabCriticas;
declare static record "reference_table"			hdlTabCriticas;

// Implementacao MVNO Demanda 94131 Inicio
//declare static record "reference_table"                 hdlTipoContratoMvno;
//declare static record "vivo_tab_tipo_contrato_mvno_rec" recTipoContratoMvno;

declare static record "reference_table"                 hdlMvnoAutorizada;
declare static record "vivo_tab_mvno_autorizada_rec"   	recMvnoAutorizada;

declare static record   "reference_table"                  hdl_vivo_tab_ccc_sms;
declare static record   "vivo_tab_ccc_sms_rec"             rec_vivo_tab_ccc_sms;

declare static record 	"reference_table"  	 	   hdl_rotas_virtuais;
declare static record 	"vivo_tab_rotas_virtuais_rec" 	   rec_rotas_virtuais;

declare static record "reference_table"			hdl_operadoras_nac;
declare static record "vivo_tab_operadoras_nac_rec" 	rec_operadoras_nac;

declare static record "reference_table"  	 	hdl_cnl_atlys;
declare static record "vivo_tab_cnl_atlys_rec"		rec_cnl_atlys;

// Implementacao MVNO Demanda 94131 Fim

//BEATRIX
declare static record "reference_table"        hOperHold;
declare static record "vivo_tab_oper_hold_rec" rOperHold;

declare static record "reference_table"        hParam;
declare static record "vivo_tab_parametro_rec"     rParam;

declare static record "reference_table"         	hdl_SepCDRCenario;
declare static record "vivo_tab_sep_cdr_cenario_rec"   	rec_SepCDRCenario;

declare static record "reference_table"				hMigcli;
declare static record "vivo_tab_migracao_rec_tbl"	rMigcli;

declare static record "reference_table"	            hId_Rcs;
declare static record "vivo_tab_depara_id_rcs_rec"  rId_Rcs;

declare static record "reference_table"	            hId_NumBRcs;
declare static record "vivo_tab_depara_numb_rcs_rec"  rId_NumBRcs;

declare static integer giRecCounter;

/* P R O T O T Y P E S ********************************************************/

prototype getEnvioEBT
(
    string sNumero,
    string sOperadora,
    record	"reference_table"		hdl_num_especiais,
    record	"vivo_tab_num_especiais_rec"	rec_num_especiais

) returns string;


prototype LookupTabMinIfast
(	string  		   	sNumber,
		record "reference_table"   	hdl_ifast,
		record "vivo_tab_min_ifast_rec"	rec_ifast
) returns string;

prototype LookupTabPrefixosNac
(	string sAssinante,
		record "reference_table" 		hdl_prefixos_nac,
		record "vivo_tab_prefixos_nac_rec"	rec_prefixos_nac
) returns integer;

prototype GetCCCinfo
(	string 				sInputPortal,
		string 				sRegional,
		record "reference_table" 	hdl_CCC,
		record "vivo_tab_ccc_rec"	rec_CCC
) returns integer;

prototype GetPortalCCCinfo
(	string 					sInputPortal,
		string 					sInputEquipment,
		record "reference_table"		hdl_CCC,
		record "vivo_tab_ccc_rec"		rec_CCC,
		record "reference_table"		hdl_RelacaoPortalCCC,
		record "vivo_tab_portal_ccc_rec"	rec_RelacaoPortalCCC
) returns integer;

prototype ConvSecsToHMS
(	integer		iNumber
)returns string;

prototype ConvHMSToSecs
(	string		sHMS
) returns string;

prototype PadZeroEsq
(	string		sString,
		integer		iTamanho
) returns string;

prototype GetParticaoPrefixoRJ
(	string sMIN,
		record	"reference_table"		hdl_prefixos_rj,
		record	"vivo_tab_prefixos_rj_rec"	rec_prefixos_rj,
		record	"reference_table"		hdl_milhares_rj,
		record	"vivo_tab_milhares_rj_rec"	rec_milhares_rj,
		record	"reference_table"		hdl_centenas_rj,
		record	"vivo_tab_centenas_rj_rec"	rec_centenas_rj,
		record	"reference_table"		hdl_dezenas_rj,
		record	"vivo_tab_dezenas_rj_rec"	rec_dezenas_rj,
		record	"reference_table"		hdl_unidades_rj,
		record	"vivo_tab_unidades_rj_rec"	rec_unidades_rj
) returns string;

prototype GetParticaoPrefixoBA
(	string sMIN,
		record	"reference_table"		hdl_prefixos_ba,
		record	"vivo_tab_prefixos_ba_rec"	rec_prefixos_ba,
		record	"reference_table"		hdl_milhares_ba,
		record	"vivo_tab_milhares_ba_rec"	rec_milhares_ba
) returns string;

prototype GetParticaoPrefixoRS
(	string sMIN,
		record	"reference_table"		hdl_prefixos_rs,
		record	"vivo_tab_prefixos_saf_rs_rec"	rec_prefixos_rs,
		record	"reference_table"		hdl_milhares_rs,
		record	"vivo_tab_milhares_saf_rs_rec"	rec_milhares_rs
) returns string;
prototype LookupVoidNull
(	string  		   	nada

) returns string;
prototype isOperadoraVIVO
(	string sOper,
		record 	"reference_table"  	 	hdl_operadoras_nac,
		record 	"vivo_tab_operadoras_nac_rec" 	rec_operadoras_nac
)  returns integer;

prototype GeraGnFcdr
(	string	sArquivoOriginal
)  returns integer;

prototype GeraGnMcdr
(	string	sArquivoOriginal
)  returns integer;

prototype GeraGnTidr
(	string	sArquivoOriginal
)  returns integer;

prototype GeraGnRsr
(	string	sArquivoOriginal
)  returns integer;

prototype GeraGnBilling
(	string	sArquivoOriginal
)  returns integer;

prototype ValidaRegistroFcdr
(	record "vivo_fcdr" INPUT
) returns string;

prototype CarregaContainerFcdr
(	
		string		sTpCdr,
		string		sDtAtendimento,
		string		sTpNumeroA,
		string		sTpNumeroB,
		string		sTpNumeroC,
		string		sTpTrafego,
		string		sCdPrestadora,
		string		sTpTarifa,
		string		sClassDistancia,
		string		sCdOperadora,
		string		sEotRotEnt,
		string		sEotRotSai,
		string		sCdOperAssA,
		string		sCdOperAssB,
		string		sCdOperAssC,
		string		sTpVisitante,
		string		sTecnologia,
		string		sDurFaturada,
		string		sDurAtend,
		string		sQtChamadas
) returns integer;

prototype CarregaContainerMcdr
(	string		sTpRegistro,
		string		sDtEnvMsg,
		string		sCausaTerm,
		string		sTpNumeroA,
		string		sTpNumeroB,
		string		sTpTrafego,
		string		sEotPlatOrig,
		string		sEotNumA,
		string		sEotNumB,
		string		sTipoSms,
		string		sTecnologia,
		string		sQtChamadas
) returns integer;

prototype CarregaContainerTidr
(	string		sTpTidr,
		string		sDtIniSessao,
		string  	sTpNumeroA,
		string		sEotNumA,
		string		sLocalizacao,
		string		sNatuServico,
		string		sGrupoHorario,
		string		sEventoMedida,
		string		sIdTarifa,
		string		sQtBytes,
		string  	sValor,
		string  	sDuracao,
		string		sQtChamadas
) returns integer;

prototype CarregaContainerRsr
(	string		sTpRsr,
		string		sDtInicio,
		string		sCdCsp,
		string		sCdEstOrigem,
		string		sCdEstDestino,
		string		sCdOperadora,
		string		sTpTarifa,
		string		sCdOperaOri,
		string		sCdOperaDes,
		string		sCdNatureza,
		string		sDegrau,
		string		sTpArquivo,
		string  	sDurChamadas,
		string  	sDurTarifada,
		string		sQtChamadas
) returns integer;

prototype CarregaContainerBilling
(	record	"vivo_irpt_gnbilling"	rBilling
) returns integer;

prototype InitializeScriptFcdr() returns integer;

prototype InitializeScriptMcdr() returns integer;

prototype InitializeScriptTidr() returns integer;

prototype InitializeScriptRsr() returns integer;

prototype InitializeScriptBilling() returns integer;

//Funcoes para gerar logs de entrada de voz/dados (IRPT)
prototype Irpt_InicializaEntrada_VozDados() returns integer;

prototype Irpt_SumarizaEntrada_VozDados
(	string 		sDataHoraEvento
) returns integer;

prototype Irpt_GeraLogEntrada_VozDados
(	string		sInterfaceExterna
) returns integer;

//Funcoes para gerar logs de saida de voz/dados (IRPT)
prototype Irpt_InicializaSaida_VozDados() returns integer;
prototype Irpt_InicializaSaida_Stage() returns integer;

prototype Irpt_SumarizaSaida_VozDados
(	string 		sRegional,
		string 		sElementoRede,
		string		sDataEvento
) returns integer;
prototype Irpt_SumarizaSaida_Stage
(	string 		sRegional,
		string 		sElementoRede,
		string		sDataEvento
) returns integer;

prototype Irpt_GeraLogSaida_VozDados
(	string		sInterfaceExterna
) returns integer;
prototype Irpt_GeraLogSaida_Stage
(	string		sInterfaceExterna
) returns integer;

//Funcoes para gerar logs de transformacao de voz/dados/terceiros (IRPT)
prototype Irpt_InicializaTransformacao() returns integer;

prototype Irpt_InicializaTransfStage() returns integer;

prototype Irpt_SumarizaTransformacao
(	string 		sStatus,
	string		sTipoCdr,
	string		sTipoNumeroA,
	string		sTipoNumeroB,
	string		sTipoNumeroC,
	string		sDataHoraEvento,
	string 		sSegundos,
	string 		sBytes,
	string		sFlagGenerateExtra
) returns integer;

prototype Irpt_SumarizaTransformacao_v2
(
		record "vivo_irpt_transformacao" rIrptTransformExterno
		/*	string 		sStatus,
	string		sTipoCdr,
	string		sTipoNumeroA,
	string		sTipoNumeroB,
	string		sTipoNumeroC,
	string		sDataHoraEvento,
	string 		sSegundos,
	string 		sBytes,
	string		sCentral,
	string		sCodigoErro,
	string		sFlagGenerateExtra
		 */
) returns integer;

prototype Irpt_SumarizaTransfStage
(
		record "vivo_irpt_transf_stage" rIrptTransfStage
) returns integer;

prototype Irpt_GeraLogTransformacao
(	string		sInterfaceExterna,
		string		sEtapa
) returns integer;

prototype Irpt_GeraLogTransfStage
(	string		sInterfaceExterna,
		string		sEtapa
) returns integer;

//Funcoes para gerar logs de entrada de terceiros (IRPT)
prototype Irpt_InicializaEntrada_Terceiros() returns integer;

prototype Irpt_SumarizaEntrada_Terceiros
(	string 		sNatureza,
		string		sOperVisitada,
		string 		sTipoChamada,
		string		sCodigoRejeicao,
		string 		sDataProcPorTerceiro,
		string		sDataHoraEvento,
		string 		sSegundos
) returns integer;

prototype Irpt_GeraLogEntrada_Terceiros
(	string		sInterfaceExterna
) returns integer;

//Funcoes para gerar logs de saida de terceiros (IRPT)
prototype Irpt_InicializaSaida_Terceiros() returns integer;

prototype Irpt_SumarizaSaida_Terceiros
(	string 		sRegional,
		string 		sElementoRede,
		string		sDataEvento,
		string		sIdentRegistro,
		string		sAreaNumeroA,
		string		sSegundos
) returns integer;

prototype Irpt_GeraLogSaida_Terceiros
(	string		sInterfaceExterna
) returns integer;

prototype Irpt_GetRegional
(	string	sEquipamentoEntrada,
		string	sPortalEntrada,
		string	sInterfaceExterna
) returns string;

prototype Irpt_GetStringParams
(	string  sEquipamentoEntrada,
		string  sPortalEntrada,
		string	sFileRegistryId
) returns integer;

prototype Mensagens_EPS
(
		string sCod,
		string sIdent
) returns integer;

prototype DestCriticas
(
		string sCod,
		string ref sdest,
		integer ref ialarme
) returns integer;

prototype InicializarVivoTabPortalCentral() returns integer;

prototype GetCentralFromTabPortalCentral() returns string;

prototype VerificaEot
(
	string sEOT,
	string sTpNumero,
	string ref sRegional,
	string ref sMovel,
	string ref sCsp
) returns integer;


// Walter Fonseca/ Franklin Verissimo / TQI - Demanda  27422 inicio 
prototype ConvertToKbytes
(
	string sValue,
	string sSizeUnit
) returns string;
// Walter Fonseca/ Franklin Verissimo / TQI - Demanda 27422 fim


// Implementacao MVNO Demanda 94131 Inicio
//prototype lookupTipoContratoMvno
//(
//    string	sEot,
//	string	ref sTipoContratacao
//) returns integer;
//
//prototype lookupMvnoAutorizada
//(
//    string	sEot,
//	string	sLac,
//	string	sDtChamada,
//	string	ref sValorMinimo,
//	integer	ref sFlagClone
//) returns integer;

prototype GetCCCfromEOT
(
    string sEOT
) returns string;

prototype GetRotaVirtual 
( 
	string sEOT 
) 
returns string;
prototype getTabOperadorasNac
(
	string 		sEot,
	string ref	sUF,
	string ref	sTipoEot
) returns integer;

prototype getEotFromCnlAtlys
(
	string sCn
) returns string;

prototype getTblOperHold
(
	string			sEOT
) returns string;

prototype getTblOperTipo
(
	string			sEOT
) returns string;

prototype getTestCase
(
	string			sFileName
) returns string;

prototype getParameter
(
string			sParameter
) returns string;

prototype VerificaSelCDRCenario
(
    string  sNum,
	string	sData
)   returns integer;

prototype VerificaSelCDRCenario2
(
    string  sNum,
	string	sData,
	record	"reference_table"				hdl_SepCDRCenario,
    record	"vivo_tab_sep_cdr_cenario_rec"	rec_SepCDRCenario
)   returns integer;

// Implementacao MVNO Demanda 94131 Fim

// Consulta Tabela de Migracao
prototype getTblMigracao
(
	string sCN_TERMINAL,
	string sDataEvento,
	record "reference_table"			hMigcli,
	record "vivo_tab_migracao_rec_tbl"	rMigcli,
	string ref	sDATA_INICIO,
	string ref	sDATA_FIM,
	string ref	sDATA_MIGRACAO,
	string ref	sSTATUS_MIGRACAO,
	string ref	sBILLING,
	string ref	sACAO,
	string ref	sLOTE
) returns integer;


prototype getEotMigNextelClaro 
(
string   Numero,
string 	 EotDe,
string ref	EotPara
)returns integer;
prototype GetDeParaIdGoogle
(
string          sId_Google,
string          sDt_Ativacao,
string          ref sMSISDN
) returns integer;

prototype GetDeParaNumBRcs
(
string          sId_Google,
string          ref sNumeroB
) returns integer;

/* M A I N ********************************************************************/
procedure main()
{
	return 1; //only for compile purpose
}

procedure VerificaEot
(
	string sEOT,
	string sTpNumero,
	string ref sRegional,
	string ref sMovel,
	string ref sCsp
	
) returns integer
{
	
	declare string sFiliadaVivo;
	sCsp		= "";
	sRegional	= "";
	sMovel 		= "";
	sFiliadaVivo	= "";
	ClassificaOperadora(sEOT, sTpNumero, sRegional, sMovel, sCsp, sFiliadaVivo);
	
	if (sFiliadaVivo != "") 
		return TRUE;
	else
		return FALSE;
}

//******************************************************************************
// Procedure:	LookupTabMinIfast
// Objetivo: 	Transformar os MIN Ifast em MIN Anatel (MDN).
//		Procura o prefixo do numero do telefone na Tabela MIN Ifast
//		atraves da chave IFAST, se encontrar o substitui pelo prefixo
//		MIN Anatel.
// Retorno:	Numero MIN Anatel
//******************************************************************************
procedure LookupTabMinIfast
(	string 				sNumber,
		record "reference_table"	hdl_ifast,
		record "vivo_tab_min_ifast_rec"	rec_ifast
) returns string
{
	declare string  sOriginalNumber;
	declare integer iPrefixLength;
	declare string  sMinPrefix;
	declare string  sMinSuffix;
	declare string  sMin;

	sOriginalNumber = sNumber;
	sMinPrefix = "";
	sMinSuffix = "";
	sMin = "";

	// Se chamada a Cobrar, entao ja e MDN
	//if ( PREFIX(sNumber, 2) == "90" && PREFIX(sNumber, 3) != "900")
	//{
	//	return sOriginalNumber;
	//	//sNumber = cgdc_substring(sNumber, 1, sizeof(sNumber)-1);
	//}

	// Se discou Codigo de Selecao de Prestadora (CP): 0CPXYABCDMCDU ou 0CPXYABCMCDU
	//if ( sizeof(sNumber) >= 12 && PREFIX(sNumber, 1) == "0" && PREFIX(sNumber, 2) != "00" )
	//{
	//	sNumber = CONCAT("0", cgdc_substring(sNumber, 3, sizeof(sNumber)-3));
	//}

	// Se discou qualquer coisa diferente de 10 digitos entao ja e MDN
	if (sizeof(sNumber) != 10)
		return sOriginalNumber;

	iPrefixLength = 9;

	while ( iPrefixLength >= 4 )
	{
		rec_ifast.IFAST = CONCAT(PREFIX(sNumber, iPrefixLength), "          ");
		if ( reference_search(hdl_ifast, rec_ifast) )
		{
			//Se achou na tabela compoe o MIN
			sMinPrefix = PREFIX(rec_ifast.MIN, iPrefixLength);
			sMinSuffix = SUFFIX(sNumber, sizeof(sNumber)-iPrefixLength);
			sMin = CONCAT(sMinPrefix, sMinSuffix);
			return sMin;
		}
		else
		{
			iPrefixLength = iPrefixLength - 1;
		}
	}

	//Se nao achou na tabela retorna o numero original procurado
	return sOriginalNumber;

} //End LookupTabMinIfast


//******************************************************************************
// Procedimento: LookupTabPrefixosNac
// Objetivo:     Pesquisa na tabela "vivo_tab_prefixos_nac"
// Retorno:      (1)TRUE/(0)FALSE e rec_prefixos preenchido
//******************************************************************************
procedure LookupTabPrefixosNac
(
		string sAssinante,
		record "reference_table" 		hdl_prefixos_nac,
		record "vivo_tab_prefixos_nac_rec"	rec_prefixos_nac
) returns integer
{
	declare string sKey;
	declare integer iStatus;

	iStatus = 0;
	sKey = PadZeroEsq(sAssinante,10);
	sKey = suffix(sKey,10);
	rec_prefixos_nac.INICIO_PREF = sKey;
	if (reference_get(hdl_prefixos_nac,rec_prefixos_nac,CGDC_REFERENCE_LTEQUAL))
	{
		if (sKey <= rec_prefixos_nac.FIM_PREF)
		{
			iStatus = 1; // Achou o prefixo na tabela
		}
	}
	return iStatus;
}


//******************************************************************************
// Procedure:	GetCCCinfo
// Objetivo:    Obtem informacoes sobre a CCC a partir do nome do Portal de
//		Entrada e da Regional (estado). Todas as informacoes sao
//		preenchidas no registro auxiliar rec_CCC.
// Retorno:	Sucesso na busca da tabela: 1, falha: 0.
//******************************************************************************
procedure GetCCCinfo
(	string 				sInputPortal,
		string 				sRegional,
		record "reference_table" 	hdl_CCC,
		record "vivo_tab_ccc_rec"	rec_CCC
) returns integer
{
	declare integer iStatus;

	rec_CCC.NOM_CCC = TABLE(sRegional)
	{
		"RJ", "ES" 		=> PREFIX(sInputPortal,3);
		"BA", "SE" 		=> PREFIX(sInputPortal,4);
		"SP"			=> PREFIX(sInputPortal,5);
		"CO", "DF", "GO", "TO", "MA",
		"MS", "MT", "RO", "AC",
		"PA", "AM", "RR", "AP"	=> PREFIX(sInputPortal,5);
		"PR", "SC" 		=> PREFIX(sInputPortal,6);
		"RS"			=> PREFIX(sInputPortal,3);
		default			=> sInputPortal;
	}

	iStatus = reference_get (hdl_CCC, rec_CCC, CGDC_REFERENCE_EQUAL);

	if (iStatus)
	{
		return TRUE; //Sucesso, achou a CCC na tabela
	}
	else
	{
		return FALSE; //Falha, nao achou a CCC na tabela
	}

} //End GetCCCinfo


//******************************************************************************
// Procedure:	GetPortalCCCinfo
// Objetivo:    Obtem informacoes sobre a CCC a partir do nome do Portal de
//		Entrada (Data Portal) e do Equipamento de Entrada (System Name).
//		Todas as informacoes sao preenchidas nos registros auxiliares
//		rec_CCC e rec_RelacaoPortalCCC.
// Retorno:	Sucesso na busca da tabela de CCC: 1, falha: 0.
//******************************************************************************
procedure GetPortalCCCinfo
(	string 					sInputPortal,
		string 					sInputEquipment,
		record "reference_table"		hdl_CCC,
		record "vivo_tab_ccc_rec"		rec_CCC,
		record "reference_table"		hdl_RelacaoPortalCCC,
		record "vivo_tab_portal_ccc_rec"	rec_RelacaoPortalCCC
) returns integer
{
	declare integer iStatus;

	//----------------------------------------------------------------------
	//Busca na tabela de relacao Portal x CCC.

	rec_RelacaoPortalCCC.SYSTEM = sInputEquipment;
	rec_RelacaoPortalCCC.PORTAL = sInputPortal;
	iStatus = reference_get (hdl_RelacaoPortalCCC, rec_RelacaoPortalCCC, CGDC_REFERENCE_EQUAL);

	if (iStatus)
	{
		rec_CCC.NOM_CCC = rec_RelacaoPortalCCC.CCC;
	}
	else
	{
		return FALSE; //Falha, nao achou o Portal na tabela
	}

	//----------------------------------------------------------------------
	//Busca da tabela de CCC.

	iStatus = reference_get (hdl_CCC, rec_CCC, CGDC_REFERENCE_EQUAL);

	if (iStatus)
	{
		return TRUE; //Sucesso, achou a CCC na tabela
	}
	else
	{
		return FALSE; //Falha, nao achou a CCC na tabela
	}

} //End GetPortalCCCinfo


//******************************************************************************
// Procedure: ConvSecsToHMS
// Objetivo:  Formata o valor em segundos para o formato HHMMSS.
// Retorno:   HHMMSS (string)
//******************************************************************************
procedure ConvSecsToHMS
(	integer iNumber
)returns string
{
	declare integer iHour;
	declare integer iMin;
	declare integer iSec;
	declare string	sOutput;
	declare string	sAux;

	iHour = iNumber / 3600;
	iMin  = (iNumber - (iHour*3600)) / 60;
	iSec  = iNumber - (iMin*60) - (iHour*3600);

	sAux = iSec;
	if ( sizeof(sAux) < 2 )
	{
		sOutput = CONCAT ("0", sAux);
	}
	else
	{
		sOutput = sAux;
	}

	sAux = iMin;
	if ( sizeof(sAux) < 2 )
	{
		sOutput = CONCAT ("0", sAux, sOutput);
	}
	else
	{
		sOutput = CONCAT (sAux, sOutput);
	}

	sAux = iHour;
	if ( sizeof(sAux) < 2 )
	{
		sOutput = CONCAT ("0", sAux, sOutput);
	}
	else
	{
		sOutput = CONCAT (sAux, sOutput);
	}

	return (sOutput);

} //End ConvSecsToHMS


//******************************************************************************
// Procedimento: ConvHMSToSecs
// Objetivo:     Converte Hora do formato HHMMSS para SSSSSS
// Retorno:      Hora no formato quantidade de segundos
//******************************************************************************
procedure ConvHMSToSecs
(	string sHMS
) returns string
{
	declare integer 	iAux;
	declare integer		iHMS;
	declare string 		sResult;

	iHMS = 0;
	if (cgdc_isdigits(sHMS) && cgdc_trim(sHMS,' ',0) != "")
	{
		// Calcula Hora em Segundos
		iAux = PREFIX(sHMS,2);
		iHMS = iAux*SECONDS_PER_HOUR;

		// Calcula Minutos em Segundos
		iAux = PREFIX(SUFFIX(sHMS,4),2);
		iHMS = iHMS + iAux*SECONDS_PER_MINUTE;

		// Calcula Segundos
		iAux = SUFFIX(sHMS,2);
		iHMS = iHMS + iAux;
	}

	//	sResult = cgdc_format("%06d",iHMS);
	sResult = iHMS;

	return sResult;

} //End ConvHMSToSecs


//******************************************************************************
// Procedimento: PadZeroEsq
// Objetivo:     Rotina utilitaria para formatacao de variaveis com Zero a Esquerda
// Retorno:      Variavel formatada
//******************************************************************************
procedure PadZeroEsq
(	string sString,
		integer iTamanho
) returns string
{
	sString = cgdc_trim(sString,' ',0);
	sString = cgdc_trim(sString,' ',CGDC_TRIM_RIGHT);
	while (iTamanho > sizeof(sString))
	{
		sString = concat("0",sString);
	}
	return (sString);
}


//******************************************************************************
// Procedimento: GetParticaoPrefixoRJ
// Objetivo:     Pesquisa nas tabelas de prefixos do RJ e devolve particao
// Retorno:      Particao do prefixo
//******************************************************************************
procedure GetParticaoPrefixoRJ
(	string sMIN,
		record	"reference_table"		hdl_prefixos_rj,
		record	"vivo_tab_prefixos_rj_rec"	rec_prefixos_rj,
		record	"reference_table"		hdl_milhares_rj,
		record	"vivo_tab_milhares_rj_rec"	rec_milhares_rj,
		record	"reference_table"		hdl_centenas_rj,
		record	"vivo_tab_centenas_rj_rec"	rec_centenas_rj,
		record	"reference_table"		hdl_dezenas_rj,
		record	"vivo_tab_dezenas_rj_rec"	rec_dezenas_rj,
		record	"reference_table"		hdl_unidades_rj,
		record	"vivo_tab_unidades_rj_rec"	rec_unidades_rj
) returns string
{
	declare string sOperPart;
	sOperPart = "";

	rec_prefixos_rj.PREFIXO = prefix(sMIN,6); // MIN = 0XYABC ou XYABCD
	if (reference_search(hdl_prefixos_rj,rec_prefixos_rj))
	{	// MIN encontrado na tabela de prefixos, verifica particao
		if (rec_prefixos_rj.OPER_PART == "999")
		{
			// Particao 999 indica desmembramento do milhar,
			// logo pesquisa com 7 digitos na tabela de milhares.
			// MIN = 0XYABCD ou XYABCDM
			rec_milhares_rj.PREFIXO = prefix(sMIN,7);
			if (reference_search(hdl_milhares_rj,rec_milhares_rj))
			{	// MIN encontrado na tabela de milhares, verifica particao
				if (rec_milhares_rj.OPER_PART == "999")
				{	// Particao 999 indica desmembramento da centena,
					// logo pesquisa com 8 digitos na tab. de centenas.
					// MIN = 0XYZBCDM ou XYABCDMC
					rec_centenas_rj.PREFIXO = prefix(sMIN,8);
					if (reference_search(hdl_centenas_rj,rec_centenas_rj))
					{	// MIN encontrado na tabela de centenas, verifica particao
						if (rec_centenas_rj.OPER_PART == "999")
						{
							// Particao 999 indica desmembramento da dezena,
							// logo pesquisa com 9 digitos na tab. de dezenas.
							// MIN = 0XYABCDMC ou XYABCDMCD
							rec_dezenas_rj.PREFIXO = prefix (sMIN,9);
							if (reference_search(hdl_dezenas_rj,rec_dezenas_rj))
							{	// Prefixo encontrado na tabela de dezenas, verif. part.
								if (rec_dezenas_rj.OPER_PART == "999")
								{
									// Particao 999 indica desmembramento ate
									// a unidade, logo pesquisa com 10 digitos
									// na tab. de unidades.
									// MIN = 0XYABCDMCD ou XYABCDMCDU
									rec_unidades_rj.PREFIXO = prefix(sMIN,10);
									if (reference_search(hdl_unidades_rj,rec_unidades_rj))
									{
										// Prefixo encontrado na tabela de unidades
										sOperPart = rec_unidades_rj.OPER_PART;
									}
								}
								else
								{
									sOperPart = rec_dezenas_rj.OPER_PART;
								}
							}
						}
						else
						{
							sOperPart = rec_centenas_rj.OPER_PART;
						}
					}
				}
				else
				{
					sOperPart = rec_milhares_rj.OPER_PART;
				}
			}
		}
		else
		{
			sOperPart = rec_prefixos_rj.OPER_PART;
		}
	}
	return sOperPart;
} //End GetParticaoPrefixoRJ


//******************************************************************************
// Procedimento: GetParticaoPrefixoBA
// Objetivo:     Pesquisa nas tabelas de prefixos da BA e devolve particao
// Retorno:      Particao do prefixo
//******************************************************************************
procedure GetParticaoPrefixoBA
(	string sMIN,
		record	"reference_table"		hdl_prefixos_ba,
		record	"vivo_tab_prefixos_ba_rec"	rec_prefixos_ba,
		record	"reference_table"		hdl_milhares_ba,
		record	"vivo_tab_milhares_ba_rec"	rec_milhares_ba
) returns string
{
	declare string sOperPart;
	sOperPart = "";

	rec_prefixos_ba.PREFIXO = prefix(sMIN,6); // MIN = 0XYABC ou XYABCD
	if (reference_search(hdl_prefixos_ba,rec_prefixos_ba))
	{	// MIN encontrado na tabela de prefixos, verifica particao
		if (rec_prefixos_ba.OPER_PART == "99")
		{
			// Particao 99 indica desmembramento do milhar,
			// logo pesquisa com 7 digitos na tabela de milhares.
			// MIN = 0XYABCD ou XYABCDM
			rec_milhares_ba.PREFIXO = prefix(sMIN,7);
			if (reference_search(hdl_milhares_ba,rec_milhares_ba))
			{	// MIN encontrado na tabela de milhares
				sOperPart = rec_milhares_ba.OPER_PART;
			}
		}
		else
		{
			sOperPart = rec_prefixos_ba.OPER_PART;
		}
	}
	return sOperPart;
} //End GetParticaoPrefixoBA


//******************************************************************************
// Procedimento: GetParticaoPrefixoRS
// Objetivo:     Pesquisa nas tabelas de prefixos do RS e devolve particao
// Retorno:      Particao do prefixo
//******************************************************************************
procedure GetParticaoPrefixoRS
(	string sMIN,
		record	"reference_table"		hdl_prefixos_rs,
		record	"vivo_tab_prefixos_saf_rs_rec"	rec_prefixos_rs,
		record	"reference_table"		hdl_milhares_rs,
		record	"vivo_tab_milhares_saf_rs_rec"	rec_milhares_rs
) returns string
{
	declare string sOperPart;
	sOperPart = "";

	rec_prefixos_rs.PREFIXO = prefix(sMIN,6); // MIN = 0XYABC ou XYABCD
	if (reference_search(hdl_prefixos_rs,rec_prefixos_rs))
	{	// MIN encontrado na tabela de prefixos, verifica particao
		if (rec_prefixos_rs.OPER_PART == "99")
		{
			// Particao 99 indica desmembramento do milhar,
			// logo pesquisa com 7 digitos na tabela de milhares.
			// MIN = 0XYABCD ou XYABCDM
			rec_milhares_rs.PREFIXO = prefix(sMIN,7);
			if (reference_search(hdl_milhares_rs,rec_milhares_rs))
			{	// MIN encontrado na tabela de milhares
				sOperPart = rec_milhares_rs.OPER_PART;
			}
		}
		else
		{
			sOperPart = rec_prefixos_rs.OPER_PART;
		}
	}
	return sOperPart;
} //End GetParticaoPrefixoRS


//******************************************************************************
// Procedimento: isOperadoraVIVO
// Objetivo:     Identifica se e uma Operadora filiada a VIVO
// Retorno:      TRUE/FALSE
//******************************************************************************
procedure isOperadoraVIVO
(	string sOper,
		record 	"reference_table"  	 	hdl_operadoras_nac,
		record 	"vivo_tab_operadoras_nac_rec" 	rec_operadoras_nac
)  returns integer
{
	rec_operadoras_nac.EOT = sOper;
	if (reference_search(hdl_operadoras_nac,rec_operadoras_nac))
	{
		if (rec_operadoras_nac.FILIADA_VIVO == "1")
			return TRUE;
	}
	return FALSE;
}


//******************************************************************************
// Procedure: CarregaContainerFcdr
// Objetivo:  Sumariza  tipo de cdr + data do atendimento + tipo numero de a +
//            tipo numero de b + tipo numero de C + tipo de trafego +
//            cod.selecao de prestadora + tipo de tarifa + class.distancia +
//            cod.operadora + eot da rota de entrada + eot da rota de saida +
//            cod.operadora ass.A + cod.operadora ass.B + cod.operadora ass.C +
//            duracao faturada + tipo de visitante.
//            Gerando informacoes para o Inter-mediatE Reporting
//	      (Data Processing Message).
//******************************************************************************
procedure CarregaContainerFcdr
(	
		string	sTpCdr,
		string	sDtAtendimento,
		string	sTpNumeroA,
		string	sTpNumeroB,
		string	sTpNumeroC,
		string	sTpTrafego,
		string	sCdPrestadora,
		string	sTpTarifa,
		string	sClassDistancia,
		string	sCdOperadora,
		string	sEotRotEnt,
		string	sEotRotSai,
		string	sCdOperAssA,
		string	sCdOperAssB,
		string	sCdOperAssC,
		string	sTpVisitante,
		string  sTecnologia,
		string	sDurFaturada,
		string	sDurAtend,
		string	sQtChamadas
)
{
	declare integer	iDurAtend;
	declare integer	iQtChamadas;
	declare integer iExisteFcdr;
	declare integer iDurFaturada;
	declare string  sContainerKeyFcdr;

	//Verifica se parametros de entrada 'duracao de atendimento' e
	//'quantidade de chamadas' sao compostos apenas de digitos.
	if ( cgdc_isdigits(sDurAtend) )
	{
		iDurAtend = sDurAtend;
	}
	else
	{
		iDurAtend = 0;
	}
	if ( cgdc_isdigits(sQtChamadas) )
	{
		iQtChamadas = sQtChamadas;
	}
	else
	{
		iQtChamadas = 0;
	}

	if ( cgdc_isdigits(sDurFaturada) )
	{
		iDurFaturada = sDurFaturada;
	}
	else
	{
		iDurFaturada = 0;
	}

	sContainerKeyFcdr = "";
	sContainerKeyFcdr = CONCAT (sTpCdr,sDtAtendimento,sTpNumeroA,sTpNumeroB,sTpNumeroC);
	sContainerKeyFcdr = CONCAT (sContainerKeyFcdr,sTpTrafego,sCdPrestadora,sTpTarifa);
	sContainerKeyFcdr = CONCAT (sContainerKeyFcdr,sClassDistancia,sCdOperadora,sEotRotEnt);
	sContainerKeyFcdr = CONCAT (sContainerKeyFcdr,sEotRotSai,sCdOperAssA,sCdOperAssB);
	sContainerKeyFcdr = CONCAT (sContainerKeyFcdr,sCdOperAssC,sTpVisitante,sTecnologia);

	iExisteFcdr = cgdc_container_get_or_add (rContainerFcdr, sContainerKeyFcdr, rGnFcdrRec, giContainerSizeFcdr);

	if (iExisteFcdr == 0) //adiciona novo registro
	{
		rGnFcdrRec.TP_CDR 		= sTpCdr;
		rGnFcdrRec.DT_ATENDIMENTO 	= sDtAtendimento;
		rGnFcdrRec.TP_NUMERO_A 		= sTpNumeroA;
		rGnFcdrRec.TP_NUMERO_B 		= sTpNumeroB;
		rGnFcdrRec.TP_NUMERO_C 		= sTpNumeroC;
		rGnFcdrRec.TP_TRAFEGO		= sTpTrafego;
		rGnFcdrRec.CD_PRESTADORA	= sCdPrestadora;
		rGnFcdrRec.TP_TARIFA		= sTpTarifa;
		rGnFcdrRec.CLASS_DISTANCIA	= sClassDistancia;
		rGnFcdrRec.CD_OPERADORA		= sCdOperadora;
		rGnFcdrRec.EOT_ROT_ENT		= sEotRotEnt;
		rGnFcdrRec.EOT_ROT_SAI		= sEotRotSai;
		rGnFcdrRec.CD_OPER_ASS_A	= sCdOperAssA;
		rGnFcdrRec.CD_OPER_ASS_B	= sCdOperAssB;
		rGnFcdrRec.CD_OPER_ASS_C	= sCdOperAssC;
		rGnFcdrRec.TP_VISITANTE		= sTpVisitante;
		rGnFcdrRec.TECNOLOGIA		= sTecnologia;
		rGnFcdrRec.DUR_FATURADA		= 0;
		rGnFcdrRec.DUR_ATEND 		= 0;
		rGnFcdrRec.QT_CHAMADAS 		= 0;
	}
	// Acumula os registro
	rGnFcdrRec.DUR_ATEND	= rGnFcdrRec.DUR_ATEND + iDurAtend;
	rGnFcdrRec.QT_CHAMADAS	= rGnFcdrRec.QT_CHAMADAS + iQtChamadas;
	rGnFcdrRec.DUR_FATURADA	= rGnFcdrRec.DUR_FATURADA + iDurFaturada;

	return DCS_OPER_OK;

} //Fim CarregaContainerFcdr


//******************************************************************************
// Procedure: CarregaContainerMcdr
// Objetivo:  Sumariza  tipo de registro + data de envia da mensagem +
//            causa terminacao + tipo numero de A + tipo numero de B +
//            tipo de trafego + eot da plataforma de origem +
//            eot de numero de A + eot de numero de B +
//            tipo de sms + tecnologia
//            Gerando informacoes para o Inter-mediatE Reporting
//	      (Data Processing Message).
//******************************************************************************
procedure CarregaContainerMcdr
(
		string	sTpRegistro,
		string	sDtEnvMsg,
		string	sCausaTerm,
		string	sTpNumeroA,
		string	sTpNumeroB,
		string	sTpTrafego,
		string	sEotPlatOrig,
		string	sEotNumA,
		string	sEotNumB,
		string	sTipoSms,
		string	sTecnologia,
		string	sQtChamadas
)
{
	declare integer iQtChamadas;
	declare integer iExisteMcdr;
	declare string  sContainerKeyMcdr;

	//Verifica se parametro de entrada 'quantidade de chamadas' eh composto
	//apenas de digitos.
	if ( cgdc_isdigits(sQtChamadas) )
	{
		iQtChamadas = sQtChamadas;
	}
	else
	{
		iQtChamadas = 0;
	}

	sContainerKeyMcdr = "";
	sContainerKeyMcdr = CONCAT (sTpRegistro,sDtEnvMsg,sCausaTerm,sTpNumeroA,sTpNumeroB);
	sContainerKeyMcdr = CONCAT (sContainerKeyMcdr,sTpTrafego,sEotPlatOrig,sEotNumA,sEotNumB,sTipoSms,sTecnologia);
	iExisteMcdr = cgdc_container_get_or_add (rContainerMcdr, sContainerKeyMcdr, rGnMcdrRec, giContainerSizeMcdr);

	if (iExisteMcdr == 0) //adiciona novo registro
	{
		rGnMcdrRec.TP_REGISTRO		= sTpRegistro;
		rGnMcdrRec.DT_ENV_MSG	 	= sDtEnvMsg;
		rGnMcdrRec.CAUSA_TERM		= sCausaTerm;
		rGnMcdrRec.TP_NUMERO_A 		= sTpNumeroA;
		rGnMcdrRec.TP_NUMERO_B 		= sTpNumeroB;
		rGnMcdrRec.TP_TRAFEGO		= sTpTrafego;
		rGnMcdrRec.EOT_PLAT_ORIG	= sEotPlatOrig;
		rGnMcdrRec.EOT_NUM_A		= sEotNumA;
		rGnMcdrRec.EOT_NUM_B		= sEotNumB;
		rGnMcdrRec.TIPO_SMS		= sTipoSms;
		rGnMcdrRec.TECNOLOGIA		= sTecnologia;
		rGnMcdrRec.QT_CHAMADAS 		= 0;
	}
	// Acumula os registro
	rGnMcdrRec.QT_CHAMADAS	= rGnMcdrRec.QT_CHAMADAS + iQtChamadas;

	return DCS_OPER_OK;

} //Fim CarregaContainerMcdr


//******************************************************************************
// Procedure: CarregaContainerTidr
// Objetivo:  Sumariza  tipo de tidr + data de inicio da sessao +
//            tipo numero de A + eot do numero A +
//            localizacao + natureza do servico + grupo horario +
//            evento de medida + identificador da tarifa aplicada.
//            Gerando informacoes para o Inter-mediatE Reporting
//	      (Data Processing Message).
//******************************************************************************
procedure CarregaContainerTidr
(
		string	sTpTidr,
		string	sDtIniSessao,
		string  sTpNumeroA,
		string	sEotNumA,
		string	sLocalizacao,
		string	sNatuServico,
		string	sGrupoHorario,
		string	sEventoMedida,
		string	sIdTarifa,
		string  sQtBytes,
		string  sValor,
		string  sDuracao,
		string	sQtChamadas
)
{
	declare integer iQtBytes;
	declare integer iValor;
	declare integer iDuracao;
	declare integer	iQtChamadas;
	declare integer iExisteTidr;
	declare string  sContainerKeyTidr;

	//Verifica se parametros de entrada 'quantidade de bytes', 'valor',
	//'duracao' e 'quantidade de chamadas' sao compostos apenas de digitos.
	if ( cgdc_isdigits(sQtBytes) )
	{
		iQtBytes = sQtBytes;
	}
	else
	{
		iQtBytes = 0;
	}
	if ( cgdc_isdigits(sValor) )
	{
		iValor = sValor;
	}
	else
	{
		iValor = 0;
	}
	if ( cgdc_isdigits(sDuracao) )
	{
		iDuracao = sDuracao;
	}
	else
	{
		iDuracao = 0;
	}
	if ( cgdc_isdigits(sQtChamadas) )
	{
		iQtChamadas = sQtChamadas;
	}
	else
	{
		iQtChamadas = 0;
	}

	sContainerKeyTidr = "";
	sContainerKeyTidr = CONCAT (sTpTidr,sDtIniSessao,sTpNumeroA,sEotNumA,sLocalizacao,sNatuServico);
	sContainerKeyTidr = CONCAT (sContainerKeyTidr,sGrupoHorario,sEventoMedida,sIdTarifa);
	iExisteTidr = cgdc_container_get_or_add (rContainerTidr, sContainerKeyTidr, rGnTidrRec, giContainerSizeTidr);

	if (iExisteTidr == 0) //adiciona novo registro
	{
		rGnTidrRec.TP_TIDR		= sTpTidr;
		rGnTidrRec.DT_INI_SESSAO	= sDtIniSessao;
		rGnTidrRec.TP_NUMERO_A 		= sTpNumeroA;
		rGnTidrRec.EOT_NUM_A 		= sEotNumA;
		rGnTidrRec.LOCALIZACAO 		= sLocalizacao;
		rGnTidrRec.NATU_SERVICO		= sNatuServico;
		rGnTidrRec.GRUPO_HORARIO	= sGrupoHorario;
		rGnTidrRec.EVENTO_MEDIDA	= sEventoMedida;
		rGnTidrRec.ID_TARIFA		= sIdTarifa;
		rGnTidrRec.QT_BYTES 		= 0;
		rGnTidrRec.VALOR 		= 0;
		rGnTidrRec.DURACAO 		= 0;
		rGnTidrRec.QT_CHAMADAS 		= 0;
	}
	// Acumula os registro
	rGnTidrRec.QT_BYTES	= rGnTidrRec.QT_BYTES    + iQtBytes;
	rGnTidrRec.VALOR	= rGnTidrRec.VALOR       + iValor;
	rGnTidrRec.DURACAO	= rGnTidrRec.DURACAO     + iDuracao;
	rGnTidrRec.QT_CHAMADAS	= rGnTidrRec.QT_CHAMADAS + iQtChamadas;

	return DCS_OPER_OK;

} //Fim CarregaContainerTidr


//******************************************************************************
// Procedure: CarregaContainerRsr
// Objetivo:  Sumariza  tipo de rsr + data de inicio+
//            csp utilizada + cod.estado de origem +
//            cod.estado de destino + codigo da operadora +
//	      tipo de tarifa + cod.operadora de origem +
//	      cod.operadora de destino + natureza de chamada +
//	      degrau da chamada + tipo de arquivo.
//            Gerando informacoes para o Inter-mediatE Reporting
//	      (Data Processing Message).
//******************************************************************************
procedure CarregaContainerRsr
(
		string	sTpRsr,
		string	sDtInicio,
		string	sCdCsp,
		string	sCdEstOrigem,
		string	sCdEstDestino,
		string	sCdOperadora,
		string	sTpTarifa,
		string	sCdOperaOri,
		string	sCdOperaDes,
		string  sCdNatureza,
		string	sDegrau,
		string	sTpArquivo,
		string  sDurChamadas,
		string  sDurTarifada,
		string	sQtChamadas
)
{
	declare integer iDurChamadas;
	declare integer iDurTarifada;
	declare integer	iQtChamadas;
	declare integer iExisteRsr;
	declare string  sContainerKeyRsr;

	//Verifica se parametros de entrada 'duracao das chamadas', 'duracao
	//tarifada' e 'quantidade de chamadas' sao compostos apenas de digitos.
	if ( cgdc_isdigits(sDurChamadas) )
	{
		iDurChamadas = sDurChamadas;
	}
	else
	{
		iDurChamadas = 0;
	}
	if ( cgdc_isdigits(sDurTarifada) )
	{
		iDurTarifada = sDurTarifada;
	}
	else
	{
		iDurTarifada = 0;
	}
	if ( cgdc_isdigits(sQtChamadas) )
	{
		iQtChamadas = sQtChamadas;
	}
	else
	{
		iQtChamadas = 0;
	}

	sContainerKeyRsr = "";
	sContainerKeyRsr = CONCAT (sTpRsr,sDtInicio,sCdCsp,sCdEstOrigem);
	sContainerKeyRsr = CONCAT (sContainerKeyRsr,sCdEstDestino,sCdOperadora,sTpTarifa,sCdOperaOri);
	sContainerKeyRsr = CONCAT (sContainerKeyRsr,sCdOperaDes,sCdNatureza,sDegrau,sTpArquivo);
	iExisteRsr = cgdc_container_get_or_add (rContainerRsr, sContainerKeyRsr, rGnRsrRec, giContainerSizeRsr);

	if (iExisteRsr == 0) //adiciona novo registro
	{
		rGnRsrRec.TP_RSR		= sTpRsr;
		rGnRsrRec.DT_INICIO		= sDtInicio;
		rGnRsrRec.CD_CSP 		= sCdCsp;
		rGnRsrRec.CD_EST_ORIGEM		= sCdEstOrigem;
		rGnRsrRec.CD_EST_DESTINO	= sCdEstDestino;
		rGnRsrRec.CD_OPERADORA		= sCdOperadora;
		rGnRsrRec.TP_TARIFA		= sTpTarifa;
		rGnRsrRec.CD_OPERA_ORI		= sCdOperaOri;
		rGnRsrRec.CD_OPERA_DES		= sCdOperaDes;
		rGnRsrRec.CD_NATUREZA		= sCdNatureza;
		rGnRsrRec.DEGRAU		= sDegrau;
		rGnRsrRec.TP_ARQUIVO		= sTpArquivo;
		rGnRsrRec.DUR_CHAMADAS 		= 0;
		rGnRsrRec.DUR_TARIFADA 		= 0;
		rGnRsrRec.QT_CHAMADAS		= 0;
	}
	// Acumula os registro
	rGnRsrRec.DUR_CHAMADAS	= rGnRsrRec.DUR_CHAMADAS + iDurChamadas;
	rGnRsrRec.DUR_TARIFADA	= rGnRsrRec.DUR_TARIFADA + iDurTarifada;
	rGnRsrRec.QT_CHAMADAS	= rGnRsrRec.QT_CHAMADAS  + iQtChamadas;

	return DCS_OPER_OK;

} //Fim CarregaContainerRsr


//******************************************************************************
// Procedure: CarregaContainerBilling
// Objetivo:  Sumariza  dados GNBilling, gerando informacoes para o Inter-mediatE Reporting
//	      (Data Processing Message).
//******************************************************************************
procedure CarregaContainerBilling
(
	record	"vivo_irpt_gnbilling"	rBilling
)
{
	declare string	sNomeArquivo;
	declare string	sTpRegistro;
	declare string	sCentral;
	declare string	sDataProcessamento;
	declare string	sCsp;
	declare string	sSentido;
	declare string	sDataEvento;
	declare string	sErb;
	declare string	sEotOrigem;
	declare string	sEotA;
	declare string	sEotB;
	declare string	sEotPG;
	declare string	sRegiaoPG;
	declare string	sTipoA;
	declare string	sTipoB;
	declare string	sTipoPG;
	declare string	sCenario;

	declare string	sContainerKey;
    	declare integer	iExiste;
    	declare integer iTamanho;
    	declare string  sDuracao;
	declare string	sValor;
	declare string	sBytes;
    	declare integer iInteger; 

	declare string	sFluxoEtapa;
    	// Inicializa variaveis
    	sDuracao = "";
	sValor	= "";
	sBytes	= "";
    	sContainerKey = "";
    	iTamanho = 0;
    	iExiste = 0;
    	iInteger = 0;
 
	sNomeArquivo		= rBilling.NOME_ARQUIVO;
	sTpRegistro		= rBilling.TP_REGISTRO;
	sCentral		= rBilling.CENTRAL;
	sFluxoEtapa		= rBilling.FLUXO_ETAPA;
	sDataProcessamento	= rBilling.DATA_PROCESS;
	sCsp			= rBilling.CSP;
	sSentido		= rBilling.SENTIDO;
	sDataEvento		= rBilling.DATA_EVENTO;
	sErb			= rBilling.ERB;
	sEotOrigem		= rBilling.EOT_ORIGEM;
	sEotA			= rBilling.EOT_A;
	sEotB			= rBilling.EOT_B;
	sEotPG			= rBilling.EOT_PG;
	sRegiaoPG		= rBilling.REGIAO_PG;
	sTipoA			= rBilling.TP_A;
	sTipoB			= rBilling.TP_B;
	sTipoPG			= rBilling.TP_PG;
	sCenario		= rBilling.CENARIO;

	sDuracao	= rBilling.DURACAO_TOTAL;
	sValor		= rBilling.VALOR_TOTAL;
	sBytes		= rBilling.QT_BYTES;

	//Se 'sNomeArquivo' vazio, substitui.
	if ( cgdc_trim(sNomeArquivo, ' ', 0) == "" )
	{
		//sNomeArquivo = "NAME_NOT_FOUND";
		sNomeArquivo = dcs_cgdc_get_string_param(DCS_CGDC_FILENAME);	
	}  
	
	//Se 'sTpRegistro' vazio, substitui.  
	if ( cgdc_trim(sTpRegistro, ' ', 0) == "" )
	{
		sTpRegistro = "-3";	
	}  
	
	//Se 'sCentral' vazio, substitui.  
	if ( cgdc_trim(sCentral, ' ', 0) == "" )
	{
		sCentral = "-3";	
	}  
	if ( cgdc_trim(sCentral, '0', 0) == "" )
	{
		sCentral = "-3";	
	} 
	//Se 'sFluxoEtapa' vazio, atribui default "1" (VOZ). 
	if ( cgdc_trim(sFluxoEtapa, ' ', 0) == "" )
	{
		sFluxoEtapa = "1";	
	} 
	if ( cgdc_trim(sFluxoEtapa, '0', 0) == "" )
	{
		sFluxoEtapa = "1";	
	}  

	//Se 'sDataProcessamento' vazio, substitui.  
	if ( cgdc_trim(sDataProcessamento, ' ', 0) == "" )
	{
		sDataProcessamento = cgdc_prefix(dcs_cgdc_get_datetime_param(DCS_CGDC_COLLECT_TIME),8);
	}  
	
	//Se 'sCsp' vazio, substitui.  
	if ( cgdc_trim(sCsp, ' ', 0) == "" )
	{
		sCsp = "-3";	
	}  
	if ( cgdc_isdigits(sCsp) == TRUE) // Elimina zeros a esquerda
	{
		iInteger = sCsp;
		sCsp = iInteger;
	}
	else
	{
		sCsp = "-3";	
	}  
   
	//Se 'sDataEvento' for vazia ou invalida, substituir pela data do sistema.
	if ( cgdc_validate_datetime_str(cgdc_concat(sDataEvento, "000000")) != 0 )
	{
		sDataEvento = cgdc_prefix(dcs_cgdc_get_datetime_param(DCS_CGDC_COLLECT_TIME),8);
	}
	
	//Se 'sEotOrigem' vazio, substitui.  
	if ( cgdc_trim(sEotOrigem, ' ', 0) == "" )
	{
		sEotOrigem = "-3";	
	}  
	if ( cgdc_trim(sEotOrigem, '0', 0) == "" 
	  || cgdc_trim(sEotOrigem, '-', 0) == "" )
	{
		sEotOrigem = "-3";	
	}  
	
	//Se 'sEotA' vazio, substitui.  
	if ( cgdc_trim(sEotA, ' ', 0) == "" )
	{
		sEotA = "-3";	
	}  
	if ( cgdc_trim(sEotA, '0', 0) == "" 
	  || cgdc_trim(sEotA, '-', 0) == "" )
	{
		sEotA = "-3";	
	}  
	
	//Se 'sEotB' vazio, substitui.  
	if ( cgdc_trim(sEotB, ' ', 0) == "" )
	{
		sEotB = "-3";	
	}  
	if ( cgdc_trim(sEotB, '0', 0) == "" 
	  || cgdc_trim(sEotB, '-', 0) == "" )
	{
		sEotB = "-3";	
	}  
	
	//Se 'sEotPG' vazio, substitui.  
	if ( cgdc_trim(sEotPG, ' ', 0) == "" )
	{
		sEotPG = "-3";	
	}  
	if ( cgdc_trim(sEotPG, '0', 0) == "" 
	  || cgdc_trim(sEotPG, '-', 0) == "" )
	{
		sEotPG = "-3";	
	}  
	
	//Se 'sRegiaoPG' vazio, substitui.  
	if ( cgdc_trim(sRegiaoPG, ' ', 0) == "" )
	{
		sRegiaoPG = "-3";	
	} 
	if ( cgdc_trim(sRegiaoPG, '-', 0) == "" )
	{
		sRegiaoPG = "-3";	
	} 
	if ( cgdc_trim(sRegiaoPG, '0', 0) == "" )
	{
		sRegiaoPG = "-3";	
	} 
 	
	//Se 'sTipoA' vazio, substitui.  
	if ( cgdc_trim(sTipoA, ' ', 0) == "" )
	{
		sTipoA = "-3";	
	}  
	if ( cgdc_trim(sTipoA, '-', 0) == "" || cgdc_trim(sTipoA, '0', 0) == "")
	{
		sTipoA = "-3";	
	}  
 	
	//Se 'sTipoB' vazio, substitui.  
	if ( cgdc_trim(sTipoB, ' ', 0) == "" )
	{
		sTipoB = "-3";	
	}  
	if ( cgdc_trim(sTipoB, '-', 0) == "" || cgdc_trim(sTipoB, '0', 0) == "")
	{
		sTipoB = "-3";	
	}  
 	
	//Se 'sCenario' vazio, substitui.  
	if ( cgdc_trim(sCenario, ' ', 0) == "" )
	{
		sCenario = "-3";	
	}
 	
	//Se 'iDuracaoTotal' nao for numerico, substitui.  
//	sDuracao = iDuracaoTotal;
	if ( cgdc_isdigits(sDuracao) == FALSE )
	{
		sDuracao = 0;	
	}  
	if ( cgdc_isdigits(sValor) == FALSE )
	{
		sValor = 0;	
	}
	if ( cgdc_isdigits(sBytes) == FALSE )
	{
		sBytes = 0;	
	}  
	//Monta chave do container para 'status' de entrada
    	sContainerKey = CONCAT( sNomeArquivo,      
				sTpRegistro,       
				sCentral,
				sFluxoEtapa,				
				sDataProcessamento,
				sCsp,              
				sDataEvento,       
				sEotOrigem,        
				sEotA,             
				sEotB,             
				sEotPG,            
				sRegiaoPG,         
				sTipoA,            
				sTipoB,            
				sCenario);

    	//Pergunta se a chave ja existe, se nao, e carregada automaticamente
    	iExiste = cgdc_container_get_or_add(rContainerBilling, sContainerKey,
                        rGnBillingRec, giContainerSizeBilling);

	//Se ainda nao existe, inicializa campos do container
    	if ( iExiste == 0 )
    	{
        	rGnBillingRec.NOME_ARQUIVO	= sNomeArquivo;
        	rGnBillingRec.TP_REGISTRO	= sTpRegistro;
        	rGnBillingRec.CENTRAL		= sCentral;
		rGnBillingRec.FLUXO_ETAPA	= sFluxoEtapa;
        	rGnBillingRec.DATA_PROCESS	= sDataProcessamento;
        	rGnBillingRec.CSP		= sCsp;
        	rGnBillingRec.SENTIDO		= "-3";
		rGnBillingRec.DATA_EVENTO	= sDataEvento;
        	rGnBillingRec.ERB		= "-3";
		rGnBillingRec.EOT_ORIGEM	= sEotOrigem;
        	rGnBillingRec.EOT_A		= sEotA;
       		rGnBillingRec.EOT_B		= sEotB;
        	rGnBillingRec.EOT_PG		= sEotPG;
        	rGnBillingRec.REGIAO_PG		= sRegiaoPG;
        	rGnBillingRec.TP_A		= sTipoA;
        	rGnBillingRec.TP_B		= sTipoB;
        	rGnBillingRec.TP_PG		= "-3";
        	//if (sTipoA != "-2" && sTipoB != "-2")
        	//{
	        //	if (sEotPG == sEotA)
	        //	{
	        //		rGnBillingRec.TP_PG = sTipoA;
	        //	}
	        //	else if (sEotPG == sEotB)
	        //	{
	        //		rGnBillingRec.TP_PG = sTipoB;
	        //	}
	        //}
        	rGnBillingRec.CENARIO		= sCenario;
        	rGnBillingRec.DATA_INCLUSAO	= sDataProcessamento;
        	rGnBillingRec.QT_REGISTROS	= "0";
		rGnBillingRec.DURACAO_TOTAL	= "0";
		rGnBillingRec.VALOR_TOTAL	= "0";
		rGnBillingRec.QT_BYTES		= "0";
    	}
	
	//Incrementa contadores
	rGnBillingRec.QT_REGISTROS     	= rGnBillingRec.QT_REGISTROS + 1;
	rGnBillingRec.DURACAO_TOTAL 	= rGnBillingRec.DURACAO_TOTAL + sDuracao;
	rGnBillingRec.VALOR_TOTAL	= rGnBillingRec.VALOR_TOTAL + sValor;
	rGnBillingRec.QT_BYTES		= rGnBillingRec.QT_BYTES + sBytes;

	return DCS_OPER_OK;

} //Fim CarregaContainerBilling


//******************************************************************************
// Procedure: InitializeScriptFcdr
// Objetivo:  Inicializa o container "VIVO_GNFCDR"
//******************************************************************************
procedure InitializeScriptFcdr()
{
	rContainerFcdr = container_init();

	if (rContainerFcdr == MAP(0))
	{
		return TRUE;
	}

	ALLOCATE (rGnFcdrRec);

	giContainerSizeFcdr = sizeof (rGnFcdrRec);

	return FALSE;

}// Fim InitializeScriptFcdr


//******************************************************************************
// Procedure: InitializeScriptMcdr
// Objetivo:  Inicializa o container "VIVO_GNMCDR"
//******************************************************************************
procedure InitializeScriptMcdr()
{
	rContainerMcdr = container_init();

	if (rContainerMcdr == MAP(0))
	{
		return TRUE;
	}

	ALLOCATE (rGnMcdrRec);

	giContainerSizeMcdr = sizeof (rGnMcdrRec);

	return FALSE;

} //Fim InitializeScriptMcdr


//******************************************************************************
// Procedure: InitializeScriptTidr
// Objetivo:  Inicializa o container "VIVO_GNTIDR"
//******************************************************************************
procedure InitializeScriptTidr()
{
	rContainerTidr = container_init();

	if (rContainerTidr == MAP(0))
	{
		return TRUE;
	}

	ALLOCATE (rGnTidrRec);

	giContainerSizeTidr = sizeof (rGnTidrRec);

	return FALSE;

} //Fim InitializeScriptTidr


//******************************************************************************
// Procedure: InitializeScriptRsr
// Objetivo:  Inicializa o container "VIVO_GNRSR"
//******************************************************************************
procedure InitializeScriptRsr()
{
	rContainerRsr = container_init();

	if (rContainerRsr == MAP(0))
	{
		return TRUE;
	}

	ALLOCATE (rGnRsrRec);

	giContainerSizeRsr = sizeof (rGnRsrRec);

	return FALSE;

} //Fim InitializeScriptRsr


//******************************************************************************
// Procedure: InitializeScriptBilling
// Objetivo:  Inicializa o container "VIVO_GNBILLING"
//******************************************************************************
procedure InitializeScriptBilling()
{
	rContainerBilling = container_init();

	if (rContainerBilling == MAP(0))
	{
		return FALSE;
	}

	ALLOCATE (rGnBillingRec);

	giContainerSizeBilling = sizeof (rGnBillingRec);

	return TRUE;

} //Fim InitializeScriptRsr


//******************************************************************************
// Procedure: GeraGnFcdr
// Objetivo:  Gera informacoes FCDR para o Inter-mediatE Reporting
//******************************************************************************
procedure GeraGnFcdr
(	string				sArquivoOriginal
) returns integer
{
	declare integer			iLocalStatus;
	declare integer			iFirstFlag;
	declare integer			iReturn;
	declare integer			iReturnDPM;
	declare	string			sDescricao;
	declare string 			sContainerKeyFcdr;
	declare string			sDpmHeader;
	declare string			sDpmDados;
	declare string			sDpmHeaderDados;

	//Gera Mensagem para o DPM
	sDescricao = "GNFCDR_NEW";
	sDpmHeader = FORMAT("NOME_ARQUIVO=%sREC,",sArquivoOriginal);

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	iFirstFlag        = 1;
	iLocalStatus      = 0;
	sContainerKeyFcdr = "";
	while ()
	{
		iLocalStatus = container_find_next (rContainerFcdr, sContainerKeyFcdr, rGnFcdrRec, giContainerSizeFcdr, iFirstFlag);
		//if no record is available, then break out of the loop
		if (iLocalStatus == 0)
		{
			break;
		}
		else
		{
			iFirstFlag = 0;
		}
		sDpmDados = "";
		sDpmDados = "TP_CDR=%s,DT_ATENDIMENTO=%s,TP_NUMERO_A=%s,TP_NUMERO_B=%s,TP_NUMERO_C=%s,TP_TRAFEGO=%s,";
		sDpmDados = CONCAT(sDpmDados,"CD_PRESTADORA=%s,TP_TARIFA=%s,CLASS_DISTANCIA=%s,CD_OPERADORA=%s,");
		sDpmDados = CONCAT(sDpmDados,"EOT_ROT_ENT=%s,EOT_ROT_SAI=%s,CD_OPER_ASS_A=%s,CD_OPER_ASS_B=%s,");
		sDpmDados = CONCAT(sDpmDados,"CD_OPER_ASS_C=%s,TP_VISITANTE=%s,DUR_FATURADA=%s,DUR_ATEND=%s,QT_CHAMADAS=%s,TECNOLOGIA=%s");
		sDpmDados = FORMAT(sDpmDados,rGnFcdrRec.TP_CDR,
				rGnFcdrRec.DT_ATENDIMENTO,
				rGnFcdrRec.TP_NUMERO_A,
				rGnFcdrRec.TP_NUMERO_B,
				rGnFcdrRec.TP_NUMERO_C,
				rGnFcdrRec.TP_TRAFEGO,
				rGnFcdrRec.CD_PRESTADORA,
				rGnFcdrRec.TP_TARIFA,
				rGnFcdrRec.CLASS_DISTANCIA,
				rGnFcdrRec.CD_OPERADORA,
				rGnFcdrRec.EOT_ROT_ENT,
				rGnFcdrRec.EOT_ROT_SAI,
				rGnFcdrRec.CD_OPER_ASS_A,
				rGnFcdrRec.CD_OPER_ASS_B,
				rGnFcdrRec.CD_OPER_ASS_C,
				rGnFcdrRec.TP_VISITANTE,
				rGnFcdrRec.DUR_FATURADA,
				rGnFcdrRec.DUR_ATEND,
				rGnFcdrRec.QT_CHAMADAS,
				rGnFcdrRec.TECNOLOGIA);
		sDpmHeaderDados = FORMAT("%s%s", sDpmHeader, sDpmDados);

		//Manda Mensagem DPM
		iReturnDPM = dcs_cgdc_dpm_put (sDescricao, "%s", sDpmHeaderDados);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}
	}
	//return DCS_OPER_OK;
	if (iLocalStatus == 0 && iFirstFlag == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	
	
} //Fim GeraFcdr


//******************************************************************************
// Procedure: GeraGnMcdr
// Objetivo:  Gera informacoes MCDR para o Inter-mediatE Reporting
//******************************************************************************
procedure GeraGnMcdr
(	string				sArquivoOriginal
) returns integer
{
	declare integer			iLocalStatus;
	declare integer			iFirstFlag;
	declare integer			iReturn;
	declare integer			iReturnDPM;
	declare	string			sDescricao;
	declare string 			sContainerKeyMcdr;
	declare string			sDpmHeader;
	declare string			sDpmDados;
	declare string			sDpmHeaderDados;

	//Gera Mensagem para o DPM
	sDescricao = "GNMCDR";
	sDpmHeader = FORMAT("NOME_ARQUIVO=%s,",sArquivoOriginal);

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;
	
	iFirstFlag        = 1;
	iLocalStatus      = 0;
	sContainerKeyMcdr = "";
	while ()
	{
		iLocalStatus = container_find_next (rContainerMcdr, sContainerKeyMcdr, rGnMcdrRec, giContainerSizeMcdr, iFirstFlag);
		//if no record is available, then break out of the loop
		if (iLocalStatus == 0)
		{
			break;
		}
		else
		{
			iFirstFlag = 0;
		}
		sDpmDados = "TP_REGISTRO=%s,DT_ENV_MSG=%s,CAUSA_TERM=%s,TP_NUMERO_A=%s,TP_NUMERO_B=%s,TP_TRAFEGO=%s,";
		sDpmDados = CONCAT(sDpmDados,"EOT_PLAT_ORIG=%s,EOT_NUM_A=%s,EOT_NUM_B=%s,");
		sDpmDados = CONCAT(sDpmDados,"TIPO_SMS=%s,TECNOLOGIA=%s,QT_CHAMADAS=%s");
		sDpmDados = FORMAT(sDpmDados,rGnMcdrRec.TP_REGISTRO,
				rGnMcdrRec.DT_ENV_MSG,
				rGnMcdrRec.CAUSA_TERM,
				rGnMcdrRec.TP_NUMERO_A,
				rGnMcdrRec.TP_NUMERO_B,
				rGnMcdrRec.TP_TRAFEGO,
				rGnMcdrRec.EOT_PLAT_ORIG,
				rGnMcdrRec.EOT_NUM_A,
				rGnMcdrRec.EOT_NUM_B,
				rGnMcdrRec.TIPO_SMS,
				rGnMcdrRec.TECNOLOGIA,
				rGnMcdrRec.QT_CHAMADAS);

		sDpmHeaderDados = FORMAT("%s%s", sDpmHeader, sDpmDados);

		//Manda Mensagem DPM
		iReturnDPM = dcs_cgdc_dpm_put (sDescricao, "%s", sDpmHeaderDados);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}
	}
	//return DCS_OPER_OK;
	if (iLocalStatus == 0 && iFirstFlag == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //Fim GeraMcdr


//******************************************************************************
// Procedure: GeraGnTidr
// Objetivo:  Gera informacoes TIDR para o Inter-mediatE Reporting
//******************************************************************************
procedure GeraGnTidr
(	string				sArquivoOriginal
) returns integer
{
	declare integer			iLocalStatus;
	declare integer			iFirstFlag;
	declare integer			iReturn;
	declare integer			iReturnDPM;
	declare	string			sDescricao;
	declare string 			sContainerKeyTidr;
	declare string			sDpmHeader;
	declare string			sDpmDados;
	declare string			sDpmHeaderDados;

	//Gera Mensagem para o DPM
	sDescricao = "GNTIDR";
	sDpmHeader = FORMAT("NOME_ARQUIVO=%sREC,", sArquivoOriginal);

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	iFirstFlag        = 1;
	iLocalStatus      = 0;
	sContainerKeyTidr = "";
	while ()
	{
		iLocalStatus = container_find_next (rContainerTidr, sContainerKeyTidr, rGnTidrRec, giContainerSizeTidr, iFirstFlag);
		//if no record is available, then break out of the loop
		if (iLocalStatus == 0)
		{
			break;
		}
		else
		{
			iFirstFlag = 0;
		}
		sDpmDados = "TP_TIDR=%s,DT_INI_SESSAO=%s,TP_NUMERO_A=%s,EOT_NUM_A=%s,LOCALIZACAO=%s,NATU_SERVICO=%s,GRUPO_HORARIO=%s,";
		sDpmDados = CONCAT(sDpmDados,"EVENTO_MEDIDA=%s,ID_TARIFA=%s,QT_BYTES=%s,VALOR=%s,DURACAO=%s,QT_CHAMADAS=%s");
		sDpmDados = FORMAT(sDpmDados,rGnTidrRec.TP_TIDR,
				rGnTidrRec.DT_INI_SESSAO,
				rGnTidrRec.TP_NUMERO_A,
				rGnTidrRec.EOT_NUM_A,
				rGnTidrRec.LOCALIZACAO,
				rGnTidrRec.NATU_SERVICO,
				rGnTidrRec.GRUPO_HORARIO,
				rGnTidrRec.EVENTO_MEDIDA,
				rGnTidrRec.ID_TARIFA,
				rGnTidrRec.QT_BYTES,
				rGnTidrRec.VALOR,
				rGnTidrRec.DURACAO,
				rGnTidrRec.QT_CHAMADAS);

		sDpmHeaderDados = FORMAT("%s%s", sDpmHeader, sDpmDados);

		//Manda Mensagem DPM
		iReturnDPM = dcs_cgdc_dpm_put (sDescricao, "%s", sDpmHeaderDados);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}
	}
	//return DCS_OPER_OK;
	if (iLocalStatus == 0 && iFirstFlag == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //Fim GeraTidr


//******************************************************************************
// Procedure: GeraGnRsr
// Objetivo:  Gera informacoes RSR para o Inter-mediatE Reporting
//******************************************************************************
procedure GeraGnRsr
(	string				sArquivoOriginal
) returns integer
{
	declare integer			iLocalStatus;
	declare integer			iFirstFlag;
	declare integer			iReturn;
	declare integer			iReturnDPM;
	declare	string			sDescricao;
	declare string 			sContainerKeyRsr;
	declare string			sDpmHeader;
	declare string			sDpmDados;
	declare string			sDpmHeaderDados;

	//Gera Mensagem para o DPM
	sDescricao = "GNRSR";
	sDpmHeader = FORMAT("NOME_ARQUIVO=%sREC,",sArquivoOriginal);

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;
	
	iFirstFlag        = 1;
	iLocalStatus      = 0;
	sContainerKeyRsr = "";
	while ()
	{
		iLocalStatus = container_find_next (rContainerRsr, sContainerKeyRsr, rGnRsrRec, giContainerSizeRsr, iFirstFlag);
		//if no record is available, then break out of the loop
		if (iLocalStatus == 0)
		{
			break;
		}
		else
		{
			iFirstFlag = 0;
		}
		sDpmDados = "TP_RSR=%s,DT_INICIO=%s,CD_CSP=%s,CD_EST_ORIGEM=%s,CD_EST_DESTINO=%s,";
		sDpmDados = CONCAT(sDpmDados,"CD_OPERADORA=%s,TP_TARIFA=%s,CD_OPERA_ORI=%s,CD_OPERA_DES=%s,");
		sDpmDados = CONCAT(sDpmDados,"CD_NATUREZA=%s,DEGRAU=%s,TP_ARQUIVO=%s,DUR_CHAMADAS=%s,DUR_TARIFADA=%s,QT_CHAMADAS=%s");
		sDpmDados = FORMAT(sDpmDados,rGnRsrRec.TP_RSR,
				rGnRsrRec.DT_INICIO,
				rGnRsrRec.CD_CSP,
				rGnRsrRec.CD_EST_ORIGEM,
				rGnRsrRec.CD_EST_DESTINO,
				rGnRsrRec.CD_OPERADORA,
				rGnRsrRec.TP_TARIFA,
				rGnRsrRec.CD_OPERA_ORI,
				rGnRsrRec.CD_OPERA_DES,
				rGnRsrRec.CD_NATUREZA,
				rGnRsrRec.DEGRAU,
				rGnRsrRec.TP_ARQUIVO,
				rGnRsrRec.DUR_CHAMADAS,
				rGnRsrRec.DUR_TARIFADA,
				rGnRsrRec.QT_CHAMADAS);

		sDpmHeaderDados = FORMAT("%s%s", sDpmHeader, sDpmDados);

		//Manda Mensagem DPM
		iReturnDPM = dcs_cgdc_dpm_put (sDescricao, "%s", sDpmHeaderDados);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}
	}
	//return DCS_OPER_OK;
	if (iLocalStatus == 0 && iFirstFlag == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //Fim GeraRsr


//******************************************************************************
// Procedure: GeraGnBilling
// Objetivo:  Gera informacoes RSR para o Inter-mediatE Reporting
//******************************************************************************
procedure GeraGnBilling
(	string				sArquivoOriginal
) returns integer
{
	declare integer		iFirstKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sContainerKey;
	declare string		sFileRegistryId;
	declare integer		seqEnvDPM;
	declare string		sData;

	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	//sInterfaceExterna = TABLE(sInterfaceExterna)
	//{
	//	"VOZ"				=> "VOZ_MEDIAT_SUMM";
	//	"DADOS"				=> "DADOS_MEDIAT_SUMM";
	//	default => SAME;
	//}

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;

	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;

	while ()
	{
		seqEnvDPM = seqEnvDPM + 1;

		iReturn = container_find_next(rContainerBilling, sContainerKey,
				rGnBillingRec, giContainerSizeBilling,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}

        	//--------------------------------------------------------------
        	//Gera mensagem no DPM
        	//
        	sData = FORMAT ("NOME_ARQUIVO=%s,TP_REGISTRO=%s,CENTRAL=%s,FLUXO_ETAPA=%s,DATA_PROCESS=%s,CSP=%s,SENTIDO=%s,DATA_EVENTO=%s,ERB=%s,EOT_ORIGEM=%s,EOT_A=%s,EOT_B=%s,EOT_PG=%s,REGIAO_PG=%s,TP_A=%s,TP_B=%s,TP_PG=%s,CENARIO=%s,DATA_INCLUSAO=%s,QT_REGISTROS=%s,DURACAO_TOTAL=%s,VALOR_TOTAL=%s,QT_BYTES=%s",
			rGnBillingRec.NOME_ARQUIVO,
        	        rGnBillingRec.TP_REGISTRO,
        	        rGnBillingRec.CENTRAL,
			rGnBillingRec.FLUXO_ETAPA,
        	        rGnBillingRec.DATA_PROCESS,
        	        rGnBillingRec.CSP,
        	        rGnBillingRec.SENTIDO,
        	        rGnBillingRec.DATA_EVENTO,
        	        rGnBillingRec.ERB,
        	        rGnBillingRec.EOT_ORIGEM,
        	        rGnBillingRec.EOT_A,
        	        rGnBillingRec.EOT_B,
        	        rGnBillingRec.EOT_PG,
        	        rGnBillingRec.REGIAO_PG,
        	        rGnBillingRec.TP_A,
        	        rGnBillingRec.TP_B,
        	        rGnBillingRec.TP_PG,
        	        rGnBillingRec.CENARIO,
        		rGnBillingRec.DATA_INCLUSAO,
        	        rGnBillingRec.QT_REGISTROS,
        	        rGnBillingRec.DURACAO_TOTAL,
        	        rGnBillingRec.VALOR_TOTAL,
        	        rGnBillingRec.QT_BYTES);              
//      	        seqEnvDPM);
        	//sData = "FILE_ID=A,REGIONAL=AXE_LDI,ELEMENTO_REDE=AXE_LDI|SPJB4,ETAPA=500,ORIGEM=NORMAL,FORMATO=LD";
        	iReturnDPM = dcs_cgdc_dpm_put("GNBILLING",sData);
        	if (iReturnDPM != 0) // FALHA
        	{
        	    break;
        	}
		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}
	}
	//return DCS_OPER_OK;

	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{

			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  	}	

} //Fim GeraGnBilling


procedure ValidaRegistroFcdr (record "vivo_fcdr" INPUT) returns string
{
	declare string  sDurAtend;
	declare integer iDurAtend;
	sDurAtend = 0;

	sDurAtend = INPUT.DURACAO_ATEND;

	if (INPUT.ST_CHAMADA == "3")  // Chamada nao completada
	{
		return "SC01";
	}

	//Verifica se parametros de entrada 'duracao de atendimento' e
	//'quantidade de chamadas' sao compostos apenas de digitos.
	if ( cgdc_isdigits(sDurAtend) )
	{
		iDurAtend = sDurAtend;
	}
	else
	{
		iDurAtend = 0;
	}

	if (iDurAtend <= 3) // Duracao menor ou igual a 3 segundos
	{
		return "SC02";
	}

	if (INPUT.TP_TARIFA    == "B5") // Identificador de tarifacao = 0 (nao tarifavel)
	{
		return "SC03";
	}

	if (INPUT.TP_CDR       == "02") // Bilhetes de terminacao na central
	{
		return "SC04";
	}

	//Esta critica e utilizada devido ao problema de identificacao do número de A das
	//chamadas terminadas nas centrais NEC Digital
	if ((INPUT.TP_CDR       == "05")  && (INPUT.TP_ROTA_ENTRADA != "E"))  // deslocamento interno ou externo
	{
		return "SC05";
	}

	if ((INPUT.TP_CDR       == "04")  && (INPUT.CLASS_DISTANCIA == "01")) // Local
	{
		return "SC06";
	}

	if ((INPUT.TP_CDR       == "03")  &&
			SUFFIX(INPUT.NUMERO_B,10) == SUFFIX(INPUT.NUMERO_C,10)) // Transferencia
	{
		return "SC06";
	}

	if (((INPUT.TP_TARIFA    == "21") ||
			(INPUT.TP_TARIFA    == "22") ||
			(INPUT.TP_TARIFA    == "23")) &&
			(iDurAtend < 18))
	{
		return "SC07";
	}

	return "101";//Registro OK

} //End ValidaRegistroFcdr


//******************************************************************************
//Procedure: Irpt_InicializaEntrada_VozDados
//Objetivo:	Inicializa container "vivo_irpt_entrada_vozdados".
//		Esta procedure deve ser invocada apenas uma vez, no INIT do
//		script de estatistica de voz ou dados.
//Entrada:	Nao ha.
//Retorno:	1: inicializou com sucesso.
//		0: houve falha na inicializacao.
//******************************************************************************
procedure Irpt_InicializaEntrada_VozDados() returns integer
{
	rEntradaVozDadosHdl = container_init();

	if ( rEntradaVozDadosHdl == MAP(0) ) //se nao inicializou
	{
		return 0;
	}

	ALLOCATE(rEntradaVozDadosRec);
	giEntradaVozDadosRecSize = sizeof(rEntradaVozDadosRec);

	return 1;

} //End Irpt_InicializaEntrada_VozDados


//******************************************************************************
//Procedure: Irpt_SumarizaEntrada_VozDados
//Objetivo:	Sumariza informacoes dos registros de arquivos de entrada de
//		voz/dados para o IRPT (Inter-mediatE Reporting).
//		As informacoes sao carregadas num container previamente definido
//		para que possam ser sumarizadas de acordo com regras definidas
//		na especificacao de Relatorios Gerenciais.
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaEntrada_VozDados para inicializar o container e
//		Irpt_GeraLogEntrada_VozDados, onde as informacoes jah sumarizadas
//		do container servirao para gerar o log atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve estar presente nos scripts de estatistica e
//		invocada sempre no tratamento de cada registro do arquivo.
//Entrada:	- sDataHoraEvento: este parametro deve entrar no formato YYYYMMDDHHMMSS.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_SumarizaEntrada_VozDados
(	string 		sDataHoraEvento
) returns integer
{
	declare datetime_string	dtDataSistema;
	declare string		sContainerKey;
	declare integer 	iExiste;

	//Para sumarizar, a 'data/hora do evento' deve ter o formato YYYYMMDDHH
	sDataHoraEvento = PREFIX(sDataHoraEvento, 10);

	//Se 'data/hora do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataHoraEvento, ' ', 0) == "" || sizeof(sDataHoraEvento) < 10 ||
			cgdc_isdigits(sDataHoraEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataHoraEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}

	//Monta chave do container
	sContainerKey = CONCAT(sDataHoraEvento);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
	iExiste = cgdc_container_get_or_add(rEntradaVozDadosHdl, sContainerKey,
			rEntradaVozDadosRec, giEntradaVozDadosRecSize);

	//Se ainda nao existe, inicializa campos do container
	if ( iExiste == 0 )
	{
		rEntradaVozDadosRec.DATA_HR_EVENTO = sDataHoraEvento;
		rEntradaVozDadosRec.TOTAL_CDRS     = 0;
	}

	//Incrementa contadores
	rEntradaVozDadosRec.TOTAL_CDRS = rEntradaVozDadosRec.TOTAL_CDRS + 1;	

	return DCS_OPER_OK;

} //End Irpt_SumarizaEntrada_VozDados


//******************************************************************************
//Procedure: Irpt_GeraLogEntrada_VozDados
//Objetivo:	Gera log com informacoes de arquivos recebidos das interfaces
//		externas (voz e dados) para o IRPT (Inter-mediatE Reporting),
//		atraves do DPM (Data Processing Message).
//		Esta procedure deve estar presente nos scripts de estatistica,
//		ou de transformacao, quando nao houver de estatistica, e
//		invocada sempre depois do tratamento do ultimo registro de cada
//		arquivo.
//		Para isso, usa-se no INIT a instrucao "dcs_cgdc_term_processing"
//		para solicitar novo processamento apos ultimo registro e no MAIN
//		a instrucao "dcs_cgdc_get_integer_param(DCS_CGDC_LAST_CALL)"
//		para identificar ultima chamada.
//Entrada:	- sInterfaceExterna: identifica se eh "VOZ" ou "DADOS".
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GeraLogEntrada_VozDados
(	string		sInterfaceExterna
) returns integer
{
	declare string		sEquipamentoEntrada;
	declare string		sPortalEntrada;
	declare string		sRegional;
	declare string		sElementoRede;
	declare string		sArquivoEntrada;
	declare string		sFileRegistryId;
	declare datetime_string	dtDataColeta;
	declare string		sDataColeta;
	declare integer		iFirstKey;
	declare string		sContainerKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sOrigem;
	declare integer		iTamanho;
	declare string		sString;
	declare integer		seqEnvDPM;
	
	iTamanho		= 0;
	sString			= "";
	
	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	sInterfaceExterna = TABLE(sInterfaceExterna)
	{
		"VOZ"	=> "VOZ_INPUT_SUMM";
		"DADOS"	=> "DADOS_INPUT_SUMM";
		default => SAME;
	}

	//Informacoes do sistema
	sEquipamentoEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP);
	sPortalEntrada      = dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL);
	sArquivoEntrada     = dcs_cgdc_get_string_param(DCS_CGDC_EXT_FILENAME);  //master file
	sFileRegistryId     = dcs_cgdc_get_string_param(DCS_CGDC_FILENAME);
	
	dtDataColeta        = dcs_cgdc_get_datetime_param(DCS_CGDC_COLLECT_TIME);
	sDataColeta         = PREFIX(dtDataColeta, 8);  //YYYYMMDD

	if ( cgdc_trim(sFileRegistryId, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sOrigem = "NORMAL";
	}
	else
	{
		//Se o registro veio do EPS (origem EPS), nao se deve gerar o log de
		//entrada, pois o log deste registro jah foi anteriormente gerado,
		//quando foi enviado a primeira vez ao EPS (com origem NORMAL).
		//Assim, evita-se contar o mesmo registro mais de uma vez quando ele
		//sair do EPS e voltar ao plano de processamento.
		sOrigem = TABLE(dcs_cgdc_filreg_get_file_type(dcs_cgdc_get_string_param(DCS_CGDC_FILENAME)))
		{
			6	=> "EPS";
			7	=> "EPS";
			11	=> "ASSEMBLED";
			default	=> "NORMAL";
		}
		
		// 200912/22 - incluido para tratamento do import de registros exportados do eps
		if (sOrigem == "NORMAL" && prefix(suffix(sArquivoEntrada,7),3) == "EPS")
		{
		    sOrigem = "EPS";
		}
	}

	//Padronização do file_registry_id
	iTamanho	    = sizeof(sFileRegistryId);
	sString		    = "";
	while (iTamanho > 0)
	{
		if (cgdc_substring(sFileRegistryId,iTamanho,1) == ".")
		{
			sString  = PREFIX(sFileRegistryId,iTamanho);		
			sFileRegistryId = sString;
			iTamanho = 0;
		}
		else
		{
			iTamanho = iTamanho - 1;
		}
	}

	if (sOrigem == "EPS")
	{
		//return DCS_OPER_OK;
		return 0;
	}

	//Se 'arquivo de entrada' vazio, substitui.
	if ( cgdc_trim(sArquivoEntrada, ' ', 0) == "" )
	{
		//sArquivoEntrada = "NAME_NOT_FOUND";
		sArquivoEntrada = sFileRegistryId;
	}

	//Elemento de Rede
	//sElementoRede = sPortalEntrada;
	sElementoRede = CONCAT(sEquipamentoEntrada, "|", sPortalEntrada);

	//Regional
	sRegional = Irpt_GetRegional(sEquipamentoEntrada,sPortalEntrada,
			sInterfaceExterna);

	// Inicializa Retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;
	
	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;

	while ()
	{
		seqEnvDPM=seqEnvDPM+1;

		iReturn = container_find_next(rEntradaVozDadosHdl, sContainerKey,
				rEntradaVozDadosRec, giEntradaVozDadosRecSize,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}

		//--------------------------------------------------------------
		//Gera mensagem no DPM
		iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
				"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,ARQUIVO_ENTRADA=%s,DATA_COLETA=%s,DATA_HR_EVENTO=%s,TOTAL_CDRS=%s, SEQ_DPM=%04d",
				sFileRegistryId,
				sRegional,
				sElementoRede,
				sArquivoEntrada,
				sDataColeta,
				rEntradaVozDadosRec.DATA_HR_EVENTO,
				rEntradaVozDadosRec.TOTAL_CDRS,
				seqEnvDPM);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}
		
		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}
		
		
	}

	//return DCS_OPER_OK;
	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //End Irpt_GeraLogEntrada_VozDados


//******************************************************************************
//Procedure: Irpt_InicializaSaida_VozDados
//Objetivo:	Inicializa container "vivo_irpt_saida_voz_dados".
//		Esta procedure deve ser invocada apenas uma vez, no INIT do
//		script de saida.
//Entrada:	Nao ha.
//Retorno:	1: inicializou com sucesso.
//		0: houve falha na inicializacao.
//******************************************************************************
procedure Irpt_InicializaSaida_VozDados() returns integer
{
	Irpt_InicializaSaida_Stage();
	rSaidaVozDadosHdl = container_init();

	if ( rSaidaVozDadosHdl == MAP(0) ) //se nao inicializou
	{
		return 0;
	}

	ALLOCATE(rSaidaVozDadosRec);
	giSaidaVozDadosRecSize = sizeof(rSaidaVozDadosRec);

	return 1;

} //End Irpt_InicializaSaida_VozDados

//******************************************************************************
//Procedure: Irpt_InicializaSaida_Stage
//Objetivo:	Inicializa container "vivo_irpt_saida_stage".
//		Esta procedure deve ser invocada apenas uma vez, no INIT do
//		script de saida.
//Entrada:	Nao ha.
//Retorno:	1: inicializou com sucesso.
//		0: houve falha na inicializacao.
//******************************************************************************
procedure Irpt_InicializaSaida_Stage() returns integer
{
	rSaidaStageHdl = container_init();

	if ( rSaidaStageHdl == MAP(0) ) //se nao inicializou
	{
		return 0;
	}

	ALLOCATE(rSaidaStageRec);
	giSaidaStageRecSize = sizeof(rSaidaStageRec);

	return 1;

} //End Irpt_InicializaSaida_Stage

//******************************************************************************
//Procedure: Irpt_SumarizaSaida_VozDados
//Objetivo:	Sumariza informacoes dos registros de arquivos de saida (voz e
//		dados) para o IRPT (Inter-mediatE Reporting).
//		As informacoes sao carregadas num container previamente definido
//		para que possam ser sumarizadas de acordo com regras definidas
//		na especificacao de Relatorios Gerenciais.
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaSaida_VozDados para inicializar o container e
//		Irpt_GeraLogSaida_VozDados, onde as informacoes jah sumarizadas
//		do container servirao para gerar o log atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve estar presente nos scripts de saida e
//		invocada sempre no tratamento de cada registro do arquivo.
//		Regional e Elemento de Rede devem ser atualizados no script de
//		saida a cada novo arquivo de entrada. Isso ocorre pois o script
//		de saida pode juntar varios arquivos de entrada para formar um
//		unico batch de saida.
//Entrada:	- sRegional.
//		- sElementoRede: equipamento_entrada|portal_entrada, ou
//				 equipamento_entrada|portal_entrada|file_id.
//		- sDataEvento: 'data do atendimento' para FCDR, 'data de entrega
//			       da mensagem' para MCDR e 'data do inicio da
//			       sessao' para TIDR, no formato YYYYMMDD.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_SumarizaSaida_VozDados
(	
		string 		sRegional,
		string 		sElementoRede,
		string		sDataEvento
) returns integer
{
	declare datetime_string	dtDataSistema;
	declare string		sContainerKey;
	declare integer 	iExiste;

	Irpt_SumarizaSaida_Stage
	(
		sRegional,
		sElementoRede,
		sDataEvento
	);

	//Verifica 'regional'
	if ( cgdc_trim(sRegional, ' ', 0) == "" )
	{
		sRegional = "XX";
	}

	//Verifica 'elemento de rede'. Este parametro pode vir sendo composto das
	//seguintes maneiras: equipamento_entrada|portal_entrada, ou
	//equipamento_entrada|portal_entrada|file_id, sendo file_id o nome do
	//arquivo derivado.
	if ( cgdc_trim(sElementoRede, ' ', 0) == "" )
	{
		sElementoRede = "XXX";
	}

	//Para sumarizar a saida, a 'data do evento' deve ter o formato YYYYMMDD
	sDataEvento = PREFIX(sDataEvento, 8);

	//Se 'data do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataEvento, ' ', 0) == "" || sizeof(sDataEvento) < 8 ||
			cgdc_isdigits(sDataEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataEvento = PREFIX(dtDataSistema, 8);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataEvento = PREFIX(dtDataSistema, 8);
	}

	//Monta chave do container
	sContainerKey = CONCAT(sRegional, sElementoRede, sDataEvento);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
	iExiste = cgdc_container_get_or_add(rSaidaVozDadosHdl, sContainerKey,
			rSaidaVozDadosRec, giSaidaVozDadosRecSize);

	//Se ainda nao existe, inicializa campos do container
	if ( iExiste == 0 )
	{
		rSaidaVozDadosRec.REGIONAL        = sRegional;
		rSaidaVozDadosRec.ELEMENTO_REDE   = sElementoRede;
		rSaidaVozDadosRec.DATA_EVENTO     = sDataEvento;
		rSaidaVozDadosRec.TOTAL_CDRS      = 0;
	}

	//Incrementa contador
	rSaidaVozDadosRec.TOTAL_CDRS = rSaidaVozDadosRec.TOTAL_CDRS + 1;

	return DCS_OPER_OK;

} //End Irpt_SumarizaSaida_VozDados


//******************************************************************************
//Procedure: Irpt_SumarizaSaida_Stage
//Objetivo:	Sumariza informacoes dos registros de arquivos de saida (Stage)
//		para o IRPT (Inter-mediatE Reporting).
//		As informacoes sao carregadas num container previamente definido
//		para que possam ser sumarizadas de acordo com regras definidas
//		na especificacao de Relatorios Gerenciais.
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaSaida_Stage para inicializar o container e
//		Irpt_GeraLogSaida_Stage, onde as informacoes jah sumarizadas
//		do container servirao para gerar o log atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve estar presente nos scripts de saida e
//		invocada sempre no tratamento de cada registro do arquivo.
//		Regional e Elemento de Rede devem ser atualizados no script de
//		saida a cada novo arquivo de entrada. Isso ocorre pois o script
//		de saida pode juntar varios arquivos de entrada para formar um
//		unico batch de saida.
//Entrada:	- sRegional.
//		- sElementoRede: equipamento_entrada|portal_entrada, ou
//				 equipamento_entrada|portal_entrada|file_id.
//		- sDataEvento: 'data do atendimento' para FCDR, 'data de entrega
//			       da mensagem' para MCDR e 'data do inicio da
//			       sessao' para TIDR, no formato YYYYMMDDHH.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_SumarizaSaida_Stage
(	
		string 		sRegional,
		string 		sElementoRede,
		string		sDataEvento
) returns integer
{
	declare datetime_string	dtDataSistema;
	declare string		sContainerKey;
	declare integer 	iExiste;

	//Verifica 'regional'
	if ( cgdc_trim(sRegional, ' ', 0) == "" )
	{
		sRegional = "XX";
	}

	//Verifica 'elemento de rede'. Este parametro pode vir sendo composto das
	//seguintes maneiras: equipamento_entrada|portal_entrada, ou
	//equipamento_entrada|portal_entrada|file_id, sendo file_id o nome do
	//arquivo derivado.
	if ( cgdc_trim(sElementoRede, ' ', 0) == "" )
	{
		sElementoRede = "XXX";
	}

	//Para sumarizar a saida, a 'data do evento' deve ter o formato YYYYMMDD
	sDataEvento = PREFIX(sDataEvento, 8);

	//Se 'data do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataEvento, ' ', 0) == "" || sizeof(sDataEvento) < 8 ||
			cgdc_isdigits(sDataEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataEvento = PREFIX(dtDataSistema, 8);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataEvento = PREFIX(dtDataSistema, 8);
	}

	//Monta chave do container
	sContainerKey = CONCAT(sRegional, sElementoRede, sDataEvento);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
	iExiste = cgdc_container_get_or_add(rSaidaStageHdl, sContainerKey,
			rSaidaStageRec, giSaidaStageRecSize);

	//Se ainda nao existe, inicializa campos do container
	if ( iExiste == 0 )
	{
		rSaidaStageRec.REGIONAL        = sRegional;
		rSaidaStageRec.ELEMENTO_REDE   = sElementoRede;
		rSaidaStageRec.DATA_EVENTO     = sDataEvento;
		rSaidaStageRec.TOTAL_CDRS      = 0;
	}

	//Incrementa contador
	rSaidaStageRec.TOTAL_CDRS = rSaidaStageRec.TOTAL_CDRS + 1;

	return DCS_OPER_OK;

} //End Irpt_SumarizaSaida_Stage


//******************************************************************************
//Procedure: Irpt_GeraLogSaida_VozDados
//Objetivo:	Gera log com informacoes de arquivos de saida (voz e dados)
//		para o IRPT (Inter-mediatE Reporting), atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaSaida_VozDados para inicializar o container e
//		Irpt_SumarizaSaida_VozDados, que sumariza num container as
//		informacoes dos registros.
//		Esta procedure deve estar presente nos scripts de saida e
//		invocada sempre depois do tratamento do ultimo registro de cada
//		arquivo.
//		Para isso, usa-se no INIT a instrucao "dcs_cgdc_term_processing"
//		para solicitar novo processamento apos ultimo registro e no MAIN
//		a instrucao "dcs_cgdc_get_integer_param(DCS_CGDC_LAST_CALL)"
//		para identificar ultima chamada.
//Entrada:	- sInterfaceExterna: identifica se eh "VOZ" ou "DADOS".
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GeraLogSaida_VozDados
(	string		sInterfaceExterna
) returns integer
{
	declare string		sDestino;
	declare datetime_string dtDataEntrega;
	declare string		sDataEntrega;
	declare string		sArquivoSaida;
	declare integer		iFirstKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sContainerKey;
	declare string		sElementoRede;
	declare string		sFileRegistryId;
	declare integer		iOffset;
	declare integer		iFirstPipeFound;
	declare integer		iTamanho;
	declare string		sString;
	declare integer		seqEnvDPM;
	
	sString  = "";
	iTamanho = 0;
	
	//Se for um RECUT, nao gerar log, pois ele jah foi gerado na primeira vez
	//que o arquivo de saida foi criado.
	if (dcs_cgdc_get_string_param(DCS_CGDC_OUTP_CUT_TYPE) == "R")
	{
		//return DCS_OPER_OK;
		return 0;
	}

	Irpt_GeraLogSaida_Stage(sInterfaceExterna);

	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	sInterfaceExterna = TABLE(sInterfaceExterna)
	{
		"VOZ"	=> "VOZ_OUTPUT_SUMM";
		"DADOS"	=> "DADOS_OUTPUT_SUMM";
		default => SAME;
	}

	//O 'destino' deve ser o portal de saida no Inter-mediatE
	//sDestino = dcs_cgdc_get_string_param(DCS_CGDC_OUTP_DATA_PORTAL);
	sDestino = CONCAT(dcs_cgdc_get_string_param(DCS_CGDC_OUTP_EXT_EQUIP),"|",dcs_cgdc_get_string_param(DCS_CGDC_OUTP_DATA_PORTAL));

	//Nome do arquivo de saida, do arquivo batch a ser formado
	sArquivoSaida = dcs_cgdc_get_string_param(DCS_CGDC_OUTP_EXT_FILENAME);

	//A 'data de entrega do arquivo' serah a data do sistema
	dtDataEntrega = cgdc_get_local_time();
	sDataEntrega = PREFIX(dtDataEntrega, 8);  //YYYYMMDD

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;

	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;

	while ()
	{

    		seqEnvDPM=seqEnvDPM+1;

		iReturn = container_find_next(rSaidaVozDadosHdl, sContainerKey,
				rSaidaVozDadosRec, giSaidaVozDadosRecSize,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}
		// Sergio Fernandes, 2005-03-16.
		// Separa a informacao de 'file_id' de dentro do campo
		// ELEMENTO_REDE, este campo pode estar preenchido das seguintes
		// maneiras: equipamento_entrada|portal_entrada, ou
		// equipamento_entrada|portal_entrada|file_id. Assim, identifica-se
		// procurando pelo segundo "|" (pipe).
		iOffset = 0;
		iFirstPipeFound = 0;
		sElementoRede = rSaidaVozDadosRec.ELEMENTO_REDE;
		sFileRegistryId = "X";
		// Ultimo byte de uma variavel string eh sempre byte zero (NULL)
		while ( BYTE(sElementoRede, iOffset) != 0x00 )
		{
			if ( BYTE(sElementoRede, iOffset) == '|' )
			{
				if ( iFirstPipeFound == 0 )
				{
					// Achei apenas o primeiro "|" (pipe).
					iFirstPipeFound = 1;
				}
				else
				{
					// Entao ha informacao de 'file registry id'.
					sElementoRede = cgdc_substring(rSaidaVozDadosRec.ELEMENTO_REDE,0,iOffset);
					sFileRegistryId = cgdc_substring(rSaidaVozDadosRec.ELEMENTO_REDE,iOffset+1,-1);
					break;
				}
			}
			iOffset = iOffset + 1;
		}

		// Verifica se 'elemento de rede' estah vazio.
		if ( cgdc_trim(sElementoRede,' ',0) == "" )
		{
			sElementoRede = "XXX";
		}

		// Verifica se 'file id' estah vazio.
		if ( cgdc_trim(sFileRegistryId,' ',0) == "" )
		{
			sFileRegistryId = "X";
		}
		//Patronizacao do File Registry Id
		iTamanho	    = sizeof(sFileRegistryId);
		sString		    = "";
		while (iTamanho > 0)
		{
			if (cgdc_substring(sFileRegistryId,iTamanho,1) == ".")
			{
				sString  = PREFIX(sFileRegistryId,iTamanho);		
				sFileRegistryId = sString;
				iTamanho = 0;
			}
			else
			{
				iTamanho = iTamanho - 1;
			}
		}



		//--------------------------------------------------------------
		//Gera mensagem no DPM
		iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
				"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,DESTINO=%s,DATA_ENTREGA=%s,ARQUIVO_SAIDA=%s,DATA_EVENTO=%s,TOTAL_CDRS=%s, SEQ_DPM=%04d",
				sFileRegistryId,
				rSaidaVozDadosRec.REGIONAL,
				sElementoRede,
				sDestino,
				sDataEntrega,
				sArquivoSaida,
				rSaidaVozDadosRec.DATA_EVENTO,
				rSaidaVozDadosRec.TOTAL_CDRS,
				seqEnvDPM);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}

		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}
		
	}

	//return DCS_OPER_OK;
	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //End Irpt_GeraLogSaida_VozDados


//******************************************************************************
//Procedure: Irpt_GeraLogSaida_Stage
//Objetivo:	Gera log com informacoes de arquivos de saida (Stage)
//		para o IRPT (Inter-mediatE Reporting), atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaSaida_Stage para inicializar o container e
//		Irpt_SumarizaSaida_Stage, que sumariza num container as
//		informacoes dos registros.
//		Esta procedure deve estar presente nos scripts de saida e
//		invocada sempre depois do tratamento do ultimo registro de cada
//		arquivo.
//		Para isso, usa-se no INIT a instrucao "dcs_cgdc_term_processing"
//		para solicitar novo processamento apos ultimo registro e no MAIN
//		a instrucao "dcs_cgdc_get_integer_param(DCS_CGDC_LAST_CALL)"
//		para identificar ultima chamada.
//Entrada:	- sInterfaceExterna: identifica se eh "VOZ" ou "DADOS".
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GeraLogSaida_Stage
(	string		sInterfaceExterna
) returns integer
{
	declare string		sDestino;
	declare datetime_string dtDataEntrega;
	declare string		sDataEntrega;
	declare string		sArquivoSaida;
	declare integer		iFirstKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sContainerKey;
	declare string		sElementoRede;
	declare string		sFileRegistryId;
	declare integer		iOffset;
	declare integer		iFirstPipeFound;
	declare integer		iTamanho;
	declare string		sString;
	declare integer		seqEnvDPM;
	
	sString  = "";
	iTamanho = 0;

	//Se for um RECUT, nao gerar log, pois ele jah foi gerado na primeira vez
	//que o arquivo de saida foi criado.
	if (dcs_cgdc_get_string_param(DCS_CGDC_OUTP_CUT_TYPE) == "R")
	{
		//return DCS_OPER_OK;
		return 0;
	}

	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	sInterfaceExterna = TABLE(sInterfaceExterna)
	{
		"VOZ"	=> "VOZ_OUTPUT_STAGE";
		"DADOS"	=> "VOZ_OUTPUT_STAGE";
		//default => "VOZ_OUTPUT_STAGE";
		//"DADOS"       => "VOZ_OUTPUT_DUMMY";
                default => "VOZ_OUTPUT_DUMMY";
	}

	//O 'destino' deve ser o portal de saida no Inter-mediatE
	//sDestino = dcs_cgdc_get_string_param(DCS_CGDC_OUTP_DATA_PORTAL);
	sDestino = CONCAT(dcs_cgdc_get_string_param(DCS_CGDC_OUTP_EXT_EQUIP),"|",dcs_cgdc_get_string_param(DCS_CGDC_OUTP_DATA_PORTAL));

	//Nome do arquivo de saida, do arquivo batch a ser formado
	sArquivoSaida = dcs_cgdc_get_string_param(DCS_CGDC_OUTP_EXT_FILENAME);

	//A 'data de entrega do arquivo' serah a data do sistema
	dtDataEntrega = cgdc_get_local_time();
	sDataEntrega = PREFIX(dtDataEntrega, 8);  //YYYYMMDD

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;

	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;

	while ()
	{

    		seqEnvDPM=seqEnvDPM+1;

		iReturn = container_find_next(rSaidaStageHdl, sContainerKey,
				rSaidaStageRec, giSaidaStageRecSize,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}
		// Sergio Fernandes, 2005-03-16.
		// Separa a informacao de 'file_id' de dentro do campo
		// ELEMENTO_REDE, este campo pode estar preenchido das seguintes
		// maneiras: equipamento_entrada|portal_entrada, ou
		// equipamento_entrada|portal_entrada|file_id. Assim, identifica-se
		// procurando pelo segundo "|" (pipe).
		iOffset = 0;
		iFirstPipeFound = 0;
		sElementoRede = rSaidaStageRec.ELEMENTO_REDE;
		sFileRegistryId = "X";
		// Ultimo byte de uma variavel string eh sempre byte zero (NULL)
		while ( BYTE(sElementoRede, iOffset) != 0x00 )
		{
			if ( BYTE(sElementoRede, iOffset) == '|' )
			{
				if ( iFirstPipeFound == 0 )
				{
					// Achei apenas o primeiro "|" (pipe).
					iFirstPipeFound = 1;
				}
				else
				{
					// Entao ha informacao de 'file registry id'.
					sElementoRede = cgdc_substring(rSaidaStageRec.ELEMENTO_REDE,0,iOffset);
					sFileRegistryId = cgdc_substring(rSaidaStageRec.ELEMENTO_REDE,iOffset+1,-1);
					break;
				}
			}
			iOffset = iOffset + 1;
		}

		// Verifica se 'elemento de rede' estah vazio.
		if ( cgdc_trim(sElementoRede,' ',0) == "" )
		{
			sElementoRede = "XXX";
		}

		// Verifica se 'file id' estah vazio.
		if ( cgdc_trim(sFileRegistryId,' ',0) == "" )
		{
			sFileRegistryId = "X";
		}
		//Patronizacao do File Registry Id
		iTamanho	    = sizeof(sFileRegistryId);
		sString		    = "";
		while (iTamanho > 0)
		{
			if (cgdc_substring(sFileRegistryId,iTamanho,1) == ".")
			{
				sString  = PREFIX(sFileRegistryId,iTamanho);		
				sFileRegistryId = sString;
				iTamanho = 0;
			}
			else
			{
				iTamanho = iTamanho - 1;
			}
		}

		//--------------------------------------------------------------
		//Gera mensagem no DPM
		iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
				"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,DESTINO=%s,DATA_ENTREGA=%s,ARQUIVO_SAIDA=%s,DATA_EVENTO=%s,TOTAL_CDRS=%s, SEQ_DPM=%04d",
				sFileRegistryId,
				rSaidaStageRec.REGIONAL,
				sElementoRede,
				sDestino,
				sDataEntrega,
				sArquivoSaida,
				rSaidaStageRec.DATA_EVENTO,
				rSaidaStageRec.TOTAL_CDRS,
				seqEnvDPM);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}

		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}
		
	}

	//return DCS_OPER_OK;
	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //End Irpt_GeraLogSaida_Stage



//******************************************************************************
//Procedure: Irpt_InicializaTransformacao
//Objetivo:	Inicializa container "vivo_irpt_transformacao".
//		Esta procedure deve ser invocada apenas uma vez, no INIT do
//		script de processos de transformacao.
//Entrada:	Nao ha.
//Retorno:	1: inicializou com sucesso.
//		0: houve falha na inicializacao.
//******************************************************************************
procedure Irpt_InicializaTransformacao() returns integer
{
	rTransformacaoHdl = container_init();

	if ( rTransformacaoHdl == MAP(0) ) //se nao inicializou
	{
		return 0;
	}

	ALLOCATE(rTransformacaoRec);
	giTransformacaoRecSize = sizeof(rTransformacaoRec);

	return 1;

} //End Irpt_InicializaTransformacao


//******************************************************************************
//Procedure: Irpt_InicializaTransfStage
//Objetivo:	Inicializa container "vivo_irpt_transformacao".
//		Esta procedure deve ser invocada apenas uma vez, no INIT do
//		script de processos de transformacao.
//Entrada:	Nao ha.
//Retorno:	1: inicializou com sucesso.
//		0: houve falha na inicializacao.
//******************************************************************************
procedure Irpt_InicializaTransfStage() returns integer
{
	rTransfStageHdl = container_init();

	if ( rTransfStageHdl == MAP(0) ) //se nao inicializou
	{
		return 0;
	}

	ALLOCATE(rTransfStageRec);
	giTransfStageRecSize = sizeof(rTransfStageRec);

	return 1;

} //End Irpt_InicializaTransfStage


//******************************************************************************
//Procedure: Irpt_SumarizaTransformacao
//Objetivo:	Sumariza informacoes dos registros de arquivos submetidos a
//		processos de transformacao para o IRPT (Inter-mediatE Reporting).
//		As informacoes sao carregadas num container previamente definido
//		para que possam ser sumarizadas de acordo com regras definidas
//		na especificacao de Relatorios Gerenciais.
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaTransformacao para inicializar o container e
//		Irpt_GeraLogTransformacao, onde as informacoes jah sumarizadas
//		do container servirao para gerar o log atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve estar presente nos scripts de transformacao
//		e invocada apos o tratamento de cada registro do arquivo.
//Entrada:	- sStatus: Cxxx - registros enviados a UNBILL ou DESCARTADOS,
//				  onde xxx eh a critica de mediacao.
//			   Exxx - registros enviados a EPS (suspensos ou rejeitados),
//				  onde xxx eh a critica de mediacao.
//			   I100 - (interno a esta funcao) total de registros que
//				  entram na operacao.
//			   Fxxx - registros formatados 'OK',
//				  onde xxx eh o codigo da proxima etapa (de destino).
//			   Gxxx - (interno a esta funcao) registros formatados 'OK',
//				  soh que derivados (clonados),
//				  onde xxx eh o codigo da proxima etapa (de destino).
//			   A052 - registros enviados a PRA para correlacao e
//				  aglutinacao de voz (Anatel 226).
//			   A051 - registros enviados a PRA para correlacao e
//				  aglutinacao de 1xRTT.
//			   D050 - registros duplicados.
//		- sTipoCdr: indica tipo do bilhete, usado unicamente quando o
//			    bilhete for FCDR (campo TP_CDR).
//		- sTipoNumeroA: codigo do tipo do assinante A, usado unicamente
//				quando bilhete for FCDR (campo TP_NUMERO_A).
//		- sTipoNumeroB: codigo do tipo do assinante B, usado unicamente
//				quando bilhete for FCDR (campo TP_NUMERO_B).
//		- sTipoNumeroC: codigo do tipo do assinante C, usado unicamente
//				quando bilhete for FCDR (campo TP_NUMERO_C).
//		- sDataHoraEvento: este parametro deve entrar no formato YYYYMMDDHHMMSS seguindo:
//					FCDR: 'data e hora de originacao'
//					MCDR: 'data de entrega da mensagem'
//					TIDR: 'data e hora do inicio da sessao'
//					Terceiros: 'data e hora de inicio'
//					SAF ECTEL: 'inicio da chamada'
//		- sSegundos: deve estar em segundos:
//					FCDR: 'duracao do atendimento'
//					Terceiros e ECTEL: 'duracao'
//		- sBytes: deve estar em bytes dependendo do caso:
//					TIDR: 'quantidade'
//		- sFlagGenerateExtra: deve ser '1' ou '0'.
//			Identifica que o registro foi clonado. Dentro do script
//			de transformacao, esse flag deve ser ativado sempre que
//			as instruces DCS_GENERATE_EXTRA ou dcs_cgdc_generate_extra()
//			forem chamadas.
//			Se nao houver 'clonagem' no script, esse parametro deve
//			sempre ser '0'.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_SumarizaTransformacao
(	string 		sStatus,
	string		sTipoCdr,
	string		sTipoNumeroA,
	string		sTipoNumeroB,
	string		sTipoNumeroC,
	string		sDataHoraEvento,
	string 		sSegundos,
	string 		sBytes,
	string		sFlagGenerateExtra
) returns integer
{
	declare datetime_string	dtDataSistema;
	declare integer		iSegundos;
	//declare integer		iBytes;
	declare unsigned long integer          	iBytes; // 24/07/09 - estouro do campo integer
	declare unsigned long integer          	iTotalBytes; // 24/07/09 - estouro do campo integer
	declare string	sTotalBytes;

	declare string		sTipoAssinante;
	declare string		sStatusAux;
	declare string		sContainerKey;
        declare integer		iExiste;

	//Se 'status' for vazio, substituir
	if ( cgdc_trim(sStatus, ' ', 0) == "" )
	{
		sStatus = "0000";
	}

	//Se 'tipo do CDR' for vazio, substituir
	if ( cgdc_trim(sTipoCdr, ' ', 0) == "" )
	{
		sTipoCdr = "XX";
	}

	//Determinacao do 'tipo do assinante' eh em funcao do 'tipo do CDR'
	sTipoAssinante = TABLE(sTipoCdr)
	{
		"01"	=> sTipoNumeroA;  //chamada orginada
		"02"	=> sTipoNumeroB;  //chamada terminada
		"03"	=> sTipoNumeroB;  //chamada de transferencia
		"04"	=> sTipoNumeroB;  //chamada de deslocamento
		"05"	=> sTipoNumeroA;  //chamada transito
		default => "X";
	}

	//Se 'tipo do assinante' for vazio, substituir
	if ( cgdc_trim(sTipoAssinante, ' ', 0) == "" )
	{
		sTipoAssinante = "X";
	}

	//Para sumarizar, a 'data/hora do evento' deve ter o formato YYYYMMDDHH
	sDataHoraEvento = PREFIX(sDataHoraEvento, 10);

	//Se 'data/hora do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataHoraEvento, ' ', 0) == "" || sizeof(sDataHoraEvento) < 10 ||
	     cgdc_isdigits(sDataHoraEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataHoraEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}

	//Verifica se parametros de entrada 'segundos' e 'bytes' sao compostos
	//apenas de digitos.
	if ( cgdc_isdigits(sSegundos) )
	{
		iSegundos = sSegundos;
	}
	else
	{
		iSegundos = 0;
	}
	if ( cgdc_isdigits(sBytes) )
	{
		iBytes = sBytes;
	}
	else
	{
		iBytes = 0;
	}

	//----------------------------------------------------------------------
	//Se o registro for 'clonado' devo gerar chave com 'status' igual a
	//"G + prox.etapa" (trocando o "F" por "G"). Senao, mantenho o 'status'.
	if ( sFlagGenerateExtra == "1" )
	{
		sStatusAux = CONCAT("G", cgdc_substring(sStatus, 1, 3));  //G + prox.etapa (Gxxx)
	}
	else
	{
		sStatusAux = sStatus;  //mantenho o status de entrada
	}

	//Monta chave do container para 'status' de entrada

        sContainerKey = CONCAT(sStatusAux, sTipoCdr, sTipoAssinante, sDataHoraEvento);

        //Pergunta se a chave jah existe, se nao, eh carregada automaticamente
        iExiste = cgdc_container_get_or_add(rTransformacaoHdl, sContainerKey,
        				    rTransformacaoRec, giTransformacaoRecSize);

	//Se ainda nao existe, inicializa campos do container
        if ( iExiste == 0 )
        {
		rTransformacaoRec.STATUS         = sStatusAux;
		rTransformacaoRec.TIPO_CDR       = sTipoCdr;
		rTransformacaoRec.TIPO_ASSINANTE = sTipoAssinante;
		rTransformacaoRec.DATA_HR_EVENTO = sDataHoraEvento;
		rTransformacaoRec.TOTAL_CDRS     = 0;
		rTransformacaoRec.TOTAL_SEGUNDOS = 0;
		rTransformacaoRec.TOTAL_BYTES    = 0;
        }

	//Incrementa contadores
	rTransformacaoRec.TOTAL_CDRS     = rTransformacaoRec.TOTAL_CDRS + 1;
	rTransformacaoRec.TOTAL_SEGUNDOS = rTransformacaoRec.TOTAL_SEGUNDOS + iSegundos;
	//rTransformacaoRec.TOTAL_BYTES    = rTransformacaoRec.TOTAL_BYTES + iBytes;
	sTotalBytes			 = "";
	iTotalBytes			 = 0;
	iTotalBytes			 = rTransformacaoRec.TOTAL_BYTES;
	iTotalBytes 			 = iTotalBytes + iBytes;
	sTotalBytes 			 = iTotalBytes;
//INC000000915502
	rTransformacaoRec.TOTAL_BYTES	 = SUFFIX(CONCAT("0000000000000000000",cgdc_trim(sTotalBytes,' ',0)),20);


	//----------------------------------------------------------------------
	//Se o registro nao for 'clonado', deve-se gerar mais uma chave para
	//'status' igual a "I100" (total de registros que entram na etapa).
//	if ( sFlagGenerateExtra == "1" )
//	{
//		return DCS_OPER_OK; //nao gera log com 'status' "I100"
//	}
//	else
//	{
		//Se o registro for duplicado, nao deve ser gerada chave de 'status' igual a "I100".
//		if ( PREFIX(sStatus, 1) == "D" )
//		{
//			return DCS_OPER_OK;
//		}
//		sStatusAux = "I100";
//	}

	//Monta chave do container para 'status' sStatusAux
//	sContainerKey = CONCAT(sStatusAux, sTipoCdr, sTipoAssinante, sDataHoraEvento);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
//	iExiste = cgdc_container_get_or_add(rTransformacaoHdl, sContainerKey,
//					    rTransformacaoRec, giTransformacaoRecSize);

	//Se ainda nao existe, inicializa campos do container
//	if ( iExiste == 0 )
//	{
//		rTransformacaoRec.STATUS         = sStatusAux;
//		rTransformacaoRec.TIPO_CDR       = sTipoCdr;
//		rTransformacaoRec.TIPO_ASSINANTE = sTipoAssinante;
//		rTransformacaoRec.DATA_HR_EVENTO = sDataHoraEvento;
//		rTransformacaoRec.TOTAL_CDRS     = 0;
//		rTransformacaoRec.TOTAL_SEGUNDOS = 0;
//		rTransformacaoRec.TOTAL_BYTES    = 0;
//	}

	//Incrementa contadores
//	rTransformacaoRec.TOTAL_CDRS     = rTransformacaoRec.TOTAL_CDRS + 1;
//	rTransformacaoRec.TOTAL_SEGUNDOS = rTransformacaoRec.TOTAL_SEGUNDOS + iSegundos;
//	rTransformacaoRec.TOTAL_BYTES    = rTransformacaoRec.TOTAL_BYTES + iBytes;

	return DCS_OPER_OK;

} //End Irpt_SumarizaTransformacao


procedure Irpt_SumarizaTransformacao_v2
(
	record "vivo_irpt_transformacao" rIrptTransformExterno
) returns integer
{
	declare string sStatus;			sStatus 			= rIrptTransformExterno.STATUS;
	declare string sTipoCdr;		sTipoCdr 			= rIrptTransformExterno.TIPO_CDR;
	declare string sDataHoraEvento;		sDataHoraEvento 		= rIrptTransformExterno.DATA_HR_EVENTO;
	declare string sSegundos;		sSegundos 			= rIrptTransformExterno.TOTAL_SEGUNDOS;
	declare string sBytes;			sBytes 				= rIrptTransformExterno.TOTAL_BYTES;
	declare string sCentral;		sCentral 			= rIrptTransformExterno.CENTRAL;
	declare string sCodigoErro;		sCodigoErro 			= rIrptTransformExterno.COD_ERRO;
	declare string sTipoNumeroA;		sTipoNumeroA 			= rIrptTransformExterno.PARAM.TIPO_NUM_A;
	declare string sTipoNumeroB;		sTipoNumeroB 			= rIrptTransformExterno.PARAM.TIPO_NUM_B;
	declare string sTipoNumeroC;		sTipoNumeroC 			= rIrptTransformExterno.PARAM.TIPO_NUM_C;
	declare string sFlagGenerateExtra;	sFlagGenerateExtra 		= rIrptTransformExterno.PARAM.FLAG_EXTRA_RECORD;
	
	giRecCounter = giRecCounter + 1;

	declare datetime_string	dtDataSistema;
	declare integer		iSegundos;
	//declare integer		iBytes;
	declare unsigned long integer          	iBytes; // 24/07/09 - estouro do campo integer
	declare unsigned long integer          	iTotalBytes; // 24/07/09 - estouro do campo integer
	declare string	sTotalBytes;

	declare string		sTipoAssinante;
	declare string		sStatusAux;
	declare string		sContainerKey;
	declare integer		iExiste;
	declare integer		iTamanho;
	declare integer		iChar;
	declare string 		sString;
	declare string 		sTipoRotaEntrada;
	declare string 		sTipoRotaSaida;
	
	sString		 = cgdc_trim(sCodigoErro,' ',0);
	iTamanho	 = sizeof(sString);
	iChar    	 = 0;
	sTipoRotaEntrada = "";
	sTipoRotaSaida	 = "";

	if (iTamanho > 2)
	{
		while (iTamanho > 0)
		{
			if (cgdc_substring(sString,iChar,1) == "|") //VERIFICA TP_ROTA_ENTRADA - Encontra o primeiro Pipe
			{
				sCodigoErro = cgdc_substring(sString,0,iChar); //Atribui o valor correto ao código de Crítica (ex: FLa, FL2...)
				iChar = iChar + 1;
				iTamanho = iTamanho - 1;
				if (cgdc_substring(sString,iChar,1) == "|") //Verifica se não possui TP_ROTA_ENTRADA
				{
					sTipoRotaEntrada = "X";
					break;
				} 
				else 
				{
					sTipoRotaEntrada = cgdc_substring(sString,iChar,1); //Se sim, atribui ao TP_ROTA_ENTRADA o valor após o Pipe
					break;
				}
			}																														//FIM VERIFICA TP_ROTA_ENTRADA
			iChar = iChar + 1;
			iTamanho = iTamanho - 1;
		} //end While
		
		if (SUFFIX(sString,1) == "|")																	//VERIFICA TP_ROTA_SAIDA - Verifica se o último caracter é Pipe
		{																															//(Se for Pipe, é porque não temos rota saída)
			sTipoRotaSaida = "X";
		} 
		else
		{
			sTipoRotaSaida = SUFFIX(sString,1);
		}
	}	
	else																													//FIM VERIFICA TP_ROTA_SAIDA
	{
		sCodigoErro = "";
	}
	//end IF
	
	//Se 'status' for vazio, substituir
	if ( cgdc_trim(sStatus, ' ', 0) == "" )
	{
		sStatus = "0000";
	}
	//Se 'tipo do CDR' for vazio, substituir
	if ( cgdc_trim(sTipoCdr, ' ', 0) == "" ) 
	{
		sTipoCdr = "XX";
	}
	//Para o FWT a variavel sTipo as Informações:
	//Tipo CDR
	//Tipo de Rota de Entrada ou Saida;	
	if (sTipoCdr == "05") 
	{		
        	sTipoCdr = TABLE(CONCAT(sTipoCdr,sTipoRotaEntrada,sTipoRotaSaida))
        	{
        		"05XI"	=> "5I"; //A
        		"05II"	=> "5I"; //A
        		"05IX"	=> "5I"; //A 
        		"05XE"	=> "5S"; //A
        		"05IE"	=> "5S"; //A
        		"05EI"	=> "5E"; //B       		
        		"05EX"	=> "5E"; //B
        		default => "05";
		}        	
	}	
	
	//Determinacao do 'tipo do assinante' eh em funcao do 'tipo do CDR'
	sTipoAssinante = TABLE(sTipoCdr)
	{
		"01"	=> sTipoNumeroA;  //chamada orginada
		"02"	=> sTipoNumeroB;  //chamada terminada
		"03"	=> sTipoNumeroB;  //chamada de transferencia
		"04"	=> sTipoNumeroB;  //chamada de deslocamento
		"05"	=> sTipoNumeroA;  //chamada transito
		"06"	=> sTipoNumeroA;  //vivo play
		"5I"	=> sTipoNumeroA;  //chamada transito com rota interna
		"5S"	=> sTipoNumeroA;  //chamada transito com rota externa
		"5E"	=> sTipoNumeroB;  //chamada transito com rota externa
		default => "X";
	}

	//Se 'tipo do assinante' for vazio, substituir
	if ( cgdc_trim(sTipoAssinante, ' ', 0) == "" )
	{
		sTipoAssinante = "X";
	}

	//Para sumarizar, a 'data/hora do evento' deve ter o formato YYYYMMDDHH
	sDataHoraEvento = PREFIX(sDataHoraEvento, 10);

	//Se 'data/hora do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataHoraEvento, ' ', 0) == "" || sizeof(sDataHoraEvento) < 10 ||
			cgdc_isdigits(sDataHoraEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataHoraEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}

	//Verifica se parametros de entrada 'segundos' e 'bytes' sao compostos
	//apenas de digitos.
	if ( cgdc_isdigits(sSegundos) )
	{
		iSegundos = sSegundos;
	}
	else
	{
		iSegundos = 0;
	}
	if ( cgdc_isdigits(sBytes) )
	{
		iBytes = sBytes;
	}
	else
	{
		iBytes = 0;
	}	
	if(cgdc_trim(sCentral, ' ', 0) == "")
	{
		sCentral = "X";
	}

	if(cgdc_trim(sCodigoErro, ' ', 0) == "")
	{
		sCodigoErro = "X";
	}

	//----------------------------------------------------------------------
	//Se o registro for 'clonado' devo gerar chave com 'status' igual a
	//"G + prox.etapa" (trocando o "F" por "G"). Senao, mantenho o 'status'.
	if ( sFlagGenerateExtra == "1" )
	{
		sStatusAux = CONCAT("G", cgdc_substring(sStatus, 1, 3));  //G + prox.etapa (Gxxx)
	}
	else
	{
		sStatusAux = sStatus;  //mantenho o status de entrada
	}

	//Monta chave do container para 'status' de entrada


	//sContainerKey = CONCAT(sStatusAux, sTipoCdr, sTipoAssinante, sDataHoraEvento);
	sContainerKey = CONCAT(sStatusAux, sTipoCdr, sTipoAssinante, sDataHoraEvento, sCentral, sCodigoErro);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
	iExiste = cgdc_container_get_or_add(rTransformacaoHdl, sContainerKey,
			rTransformacaoRec, giTransformacaoRecSize);

	//Se ainda nao existe, inicializa campos do container
	if ( iExiste == 0 )
	{
		rTransformacaoRec.STATUS         = sStatusAux;
		rTransformacaoRec.TIPO_CDR       = sTipoCdr;
		rTransformacaoRec.TIPO_ASSINANTE = sTipoAssinante;
		rTransformacaoRec.DATA_HR_EVENTO = sDataHoraEvento;
		rTransformacaoRec.CENTRAL        = sCentral;
		rTransformacaoRec.COD_ERRO       = sCodigoErro;
		rTransformacaoRec.TOTAL_CDRS     = 0;
		rTransformacaoRec.TOTAL_SEGUNDOS = 0;
		rTransformacaoRec.TOTAL_BYTES    = 0;
	}
	
	//Incrementa contadores
	rTransformacaoRec.TOTAL_CDRS     = rTransformacaoRec.TOTAL_CDRS + 1;
	rTransformacaoRec.TOTAL_SEGUNDOS = rTransformacaoRec.TOTAL_SEGUNDOS + iSegundos;
	//rTransformacaoRec.TOTAL_BYTES    = rTransformacaoRec.TOTAL_BYTES + iBytes;
	
	sTotalBytes			 = "";
	iTotalBytes			 = 0;
	iTotalBytes			 = rTransformacaoRec.TOTAL_BYTES;
	iTotalBytes 			 = iTotalBytes + iBytes;
	sTotalBytes 			 = iTotalBytes;	
	// Walter Fonseca - Chamado  20525185 inicio
	rTransformacaoRec.TOTAL_BYTES	 = SUFFIX(CONCAT("0000000000000000000",cgdc_trim(sTotalBytes,' ',0)),20);
	// Walter Fonseca - Chamado 20525185 fim
	return DCS_OPER_OK;

} //End Irpt_SumarizaTransformacao_v2


procedure Irpt_SumarizaTransfStage
(
	record "vivo_irpt_transf_stage" rIrptTransfStage
) returns integer
{
	declare string sStatus;			sStatus 			= rIrptTransfStage.STATUS;
	declare string sTipoCdr;		sTipoCdr 			= rIrptTransfStage.TIPO_CDR;
	declare string sDataHoraEvento;		sDataHoraEvento 		= rIrptTransfStage.DATA_HR_EVENTO;
	declare string sSegundos;		sSegundos 			= rIrptTransfStage.TOTAL_SEGUNDOS;
	declare string sBytes;			sBytes 				= rIrptTransfStage.TOTAL_BYTES;
	declare string sCentral;		sCentral 			= rIrptTransfStage.CENTRAL;
	declare string sCodigoErro;		sCodigoErro 			= rIrptTransfStage.COD_ERRO;
	declare string sClassificacao;	sClassificacao			= rIrptTransfStage.CLASSIFICACAO;
	declare string sTipoNumeroA;		sTipoNumeroA 			= rIrptTransfStage.PARAM.TIPO_NUM_A;
	declare string sTipoNumeroB;		sTipoNumeroB 			= rIrptTransfStage.PARAM.TIPO_NUM_B;
	declare string sTipoNumeroC;		sTipoNumeroC 			= rIrptTransfStage.PARAM.TIPO_NUM_C;
	declare string sFlagGenerateExtra;	sFlagGenerateExtra 		= rIrptTransfStage.PARAM.FLAG_EXTRA_RECORD;
	
	giRecCounter = giRecCounter + 1;

	declare datetime_string	dtDataSistema;
	declare integer		iSegundos;
	//declare integer		iBytes;
	declare unsigned long integer          	iBytes; // 24/07/09 - estouro do campo integer
	declare unsigned long integer          	iTotalBytes; // 24/07/09 - estouro do campo integer
	declare string	sTotalBytes;

	declare string		sTipoAssinante;
	declare string		sStatusAux;
	declare string		sContainerKey;
	declare integer		iExiste;
	declare integer		iTamanho;
	declare integer		iChar;
	declare string 		sString;
	declare string 		sTipoRotaEntrada;
	declare string 		sTipoRotaSaida;
	
	sString		 = cgdc_trim(sCodigoErro,' ',0);
	iTamanho	 = sizeof(sString);
	iChar    	 = 0;
	sTipoRotaEntrada = "";
	sTipoRotaSaida	 = "";

	if (iTamanho > 2)
	{
		while (iTamanho > 0)
		{
			if (cgdc_substring(sString,iChar,1) == "|") //VERIFICA TP_ROTA_ENTRADA - Encontra o primeiro Pipe
			{
				sCodigoErro = cgdc_substring(sString,0,iChar); //Atribui o valor correto ao código de Crítica (ex: FLa, FL2...)
				iChar = iChar + 1;
				iTamanho = iTamanho - 1;
				if (cgdc_substring(sString,iChar,1) == "|") //Verifica se não possui TP_ROTA_ENTRADA
				{
					sTipoRotaEntrada = "X";
					break;
				} 
				else 
				{
					sTipoRotaEntrada = cgdc_substring(sString,iChar,1); //Se sim, atribui ao TP_ROTA_ENTRADA o valor após o Pipe
					break;
				}
			}																														//FIM VERIFICA TP_ROTA_ENTRADA
			iChar = iChar + 1;
			iTamanho = iTamanho - 1;
		} //end While
		
		if (SUFFIX(sString,1) == "|")																	//VERIFICA TP_ROTA_SAIDA - Verifica se o último caracter é Pipe
		{																															//(Se for Pipe, é porque não temos rota saída)
			sTipoRotaSaida = "X";
		} 
		else
		{
			sTipoRotaSaida = SUFFIX(sString,1);
		}
	}	
	else																													//FIM VERIFICA TP_ROTA_SAIDA
	{
		sCodigoErro = "";
	}
	//end IF

	//Se 'classificacao' for vazio, atribuir '-3'
	if ( cgdc_trim(sClassificacao, ' ', 0) == "")
	{
		sClassificacao	= "-3";
	}
	
	//Se 'status' for vazio, substituir
	if ( cgdc_trim(sStatus, ' ', 0) == "" )
	{
		sStatus = "0000";
	}
	//Se 'tipo do CDR' for vazio, substituir
	if ( cgdc_trim(sTipoCdr, ' ', 0) == "" ) 
	{
		sTipoCdr = "XX";
	}
	//Para o FWT a variavel sTipo as Informações:
	//Tipo CDR
	//Tipo de Rota de Entrada ou Saida;	
	if (sTipoCdr == "05") 
	{		
        	sTipoCdr = TABLE(CONCAT(sTipoCdr,sTipoRotaEntrada,sTipoRotaSaida))
        	{
        		"05XI"	=> "5I"; //A
        		"05II"	=> "5I"; //A
        		"05IX"	=> "5I"; //A 
        		"05XE"	=> "5S"; //A
        		"05IE"	=> "5S"; //A
        		"05EI"	=> "5E"; //B       		
        		"05EX"	=> "5E"; //B
        		default => "05";
		}        	
	}	
	
	//Determinacao do 'tipo do assinante' eh em funcao do 'tipo do CDR'
	sTipoAssinante = TABLE(sTipoCdr)
	{
		"01"	=> sTipoNumeroA;  //chamada orginada
		"02"	=> sTipoNumeroB;  //chamada terminada
		"03"	=> sTipoNumeroB;  //chamada de transferencia
		"04"	=> sTipoNumeroB;  //chamada de deslocamento
		"05"	=> sTipoNumeroA;  //chamada transito
		"06"	=> sTipoNumeroA;  //vivo play
		"5I"	=> sTipoNumeroA;  //chamada transito com rota interna
		"5S"	=> sTipoNumeroA;  //chamada transito com rota externa
		"5E"	=> sTipoNumeroB;  //chamada transito com rota externa
		default => "X";
	}

	//Se 'tipo do assinante' for vazio, substituir
	if ( cgdc_trim(sTipoAssinante, ' ', 0) == "" )
	{
		sTipoAssinante = "X";
	}

	//Para sumarizar, a 'data/hora do evento' deve ter o formato YYYYMMDDHH
	sDataHoraEvento = PREFIX(sDataHoraEvento, 10);

	//Se 'data/hora do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataHoraEvento, ' ', 0) == "" || sizeof(sDataHoraEvento) < 10 ||
			cgdc_isdigits(sDataHoraEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataHoraEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}

	//Verifica se parametros de entrada 'segundos' e 'bytes' sao compostos
	//apenas de digitos.
	if ( cgdc_isdigits(sSegundos) )
	{
		iSegundos = sSegundos;
	}
	else
	{
		iSegundos = 0;
	}
	if ( cgdc_isdigits(sBytes) )
	{
		iBytes = sBytes;
	}
	else
	{
		iBytes = 0;
	}	
	if(cgdc_trim(sCentral, ' ', 0) == "")
	{
		sCentral = "X";
	}

	if(cgdc_trim(sCodigoErro, ' ', 0) == "")
	{
		sCodigoErro = "X";
	}

	//----------------------------------------------------------------------
	//Se o registro for 'clonado' devo gerar chave com 'status' igual a
	//"G + prox.etapa" (trocando o "F" por "G"). Senao, mantenho o 'status'.
	if ( sFlagGenerateExtra == "1" )
	{
		sStatusAux = CONCAT("G", cgdc_substring(sStatus, 1, 3));  //G + prox.etapa (Gxxx)
	}
	else
	{
		sStatusAux = sStatus;  //mantenho o status de entrada
	}

	//Monta chave do container para 'status' de entrada


	//sContainerKey = CONCAT(sStatusAux, sTipoCdr, sTipoAssinante, sDataHoraEvento);
//	sContainerKey = CONCAT(sStatusAux, sTipoCdr, sTipoAssinante, sDataHoraEvento, sCentral, sCodigoErro, sClassificacao);
	sContainerKey = CONCAT(sStatusAux, sTipoCdr, sTipoAssinante, sDataHoraEvento, sCentral, sCodigoErro);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
	iExiste = cgdc_container_get_or_add(rTransfStageHdl, sContainerKey,
			rTransfStageRec, giTransfStageRecSize);

	//Se ainda nao existe, inicializa campos do container
	if ( iExiste == 0 )
	{
		rTransfStageRec.STATUS         = sStatusAux;
		rTransfStageRec.TIPO_CDR       = sTipoCdr;
		rTransfStageRec.TIPO_ASSINANTE = sTipoAssinante;
		rTransfStageRec.DATA_HR_EVENTO = sDataHoraEvento;
		rTransfStageRec.CENTRAL        = sCentral;
		rTransfStageRec.COD_ERRO       = sCodigoErro;
		rTransfStageRec.CLASSIFICACAO	= sClassificacao;
		rTransfStageRec.TOTAL_CDRS     = 0;
		rTransfStageRec.TOTAL_SEGUNDOS = 0;
		rTransfStageRec.TOTAL_BYTES    = 0;
	}
	
	//Incrementa contadores
	rTransfStageRec.TOTAL_CDRS     = rTransfStageRec.TOTAL_CDRS + 1;
	rTransfStageRec.TOTAL_SEGUNDOS = rTransfStageRec.TOTAL_SEGUNDOS + iSegundos;
	//rTransformacaoRec.TOTAL_BYTES    = rTransformacaoRec.TOTAL_BYTES + iBytes;
	
	sTotalBytes			 = "";
	iTotalBytes			 = 0;
	iTotalBytes			 = rTransfStageRec.TOTAL_BYTES;
	iTotalBytes 			 = iTotalBytes + iBytes;
	sTotalBytes 			 = iTotalBytes;	
	// Walter Fonseca - Chamado  20525185 inicio
	rTransfStageRec.TOTAL_BYTES	 = SUFFIX(CONCAT("0000000000000000000",cgdc_trim(sTotalBytes,' ',0)),20);
	// Walter Fonseca - Chamado 20525185 fim
	return DCS_OPER_OK;

} //End Irpt_SumarizaTransfStage


//******************************************************************************
//Procedure: Irpt_GeraLogTransformacao
//Objetivo:	Gera log com informacoes dos registros de arquivos submetidos a
//		processos de transformacao para o IRPT (Inter-mediatE Reporting),
//		atraves do DPM (Data Processing Message).
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaTransformacao para inicializar o container e
//		Irpt_SumarizaTransformacao, que sumariza num container as
//		informacoes dos registros.
//		Esta procedure deve estar presente nos scripts de transformacao e
//		invocada sempre depois do tratamento do ultimo registro de cada
//		arquivo.
//		Para isso, usa-se no INIT a instrucao "dcs_cgdc_term_processing"
//		para solicitar novo processamento apos ultimo registro e no MAIN
//		a instrucao "dcs_cgdc_get_integer_param(DCS_CGDC_LAST_CALL)"
//		para identificar ultima chamada de processamento.
//Entrada:	- sInterfaceExterna: identifica se eh "VOZ", "DADOS", "TERCEIROS".
//		- sEtapa: etapa do processamento, de acordo com definicao em
//			  tabela de fluxo de processos (3 caracteres).
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GeraLogTransformacao
(	string		sInterfaceExterna,
		string		sEtapa
) returns integer
{
	declare string		sEquipamentoEntrada;
	declare string		sPortalEntrada;
	declare string		sRegional;
	declare string		sElementoRede;
	declare string		sOrigem;
	declare integer		iFirstKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sContainerKey;
	declare string		sFileRegistryId;
	declare integer		iTamanho;
	declare string		sString;	
	declare integer		seqEnvDPM;

	iTamanho = 0;
	sString	 = "";
	
	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	sInterfaceExterna = TABLE(sInterfaceExterna)
	{
		"VOZ"				=> "VOZ_MEDIAT_SUMM";
		"VOZ_v2","VOZ_V2"		=> "VOZ_MEDIAT_SUMM_v2";
		"DADOS"				=> "DADOS_MEDIAT_SUMM";
		"DADOS_v2","DADOS_V2"		=> "DADOS_MEDIAT_SUMM_v2";
		"TERCEIROS"			=> "TERC_MEDIAT_SUMM";
		"TERCEIROS_v2","TERCEIROS_V2"	=> "TERC_MEDIAT_SUMM_v2";
		"TCO"				=> "TERC_MEDIAT_SUMM";
		"TFI"				=> "TERC_MEDIAT_SUMM";
		"ROI"				=> "TERC_MEDIAT_SUMM";
		default => SAME;
	}

	//Se 'etapa' tiver menos de 3 caracteres, acrescentar '0' a esquerda
	sEtapa = PadZeroEsq(sEtapa, 3);

	//Identificacao do arquivo de entrada no File Registry, interno ao Inter-mediatE.
	sFileRegistryId = dcs_cgdc_get_string_param(DCS_CGDC_FILENAME);
	
	if ( cgdc_trim(sFileRegistryId, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sFileRegistryId = gsFileRegistryId;
		sOrigem 	= "NORMAL";
	}
	else
	{
		//Determinacao da 'origem', ou seja, se o arquivo veio do fluxo normal,
		//se veio do EPS ou se foi 'aglutinado' pelo PRA.
		sOrigem = TABLE(dcs_cgdc_filreg_get_file_type(dcs_cgdc_get_string_param(DCS_CGDC_FILENAME)))
		{
			6	=> "EPS";
			7	=> "EPS";
			11	=> "ASSEMBLED";
			default	=> "NORMAL";
		}

        // 200912/22 - incluido para tratamento do import de registros exportados do eps
		if (sOrigem == "NORMAL" && prefix(suffix(dcs_cgdc_get_string_param(DCS_CGDC_EXT_FILENAME),7),3) == "EPS")
		{
		    sOrigem = "EPS";
		}		
		
	}

	//Patronizacao do File Registry Id
	iTamanho	    = sizeof(sFileRegistryId);
	sString		    = "";
	while (iTamanho > 0)
	{
		if (cgdc_substring(sFileRegistryId,iTamanho,1) == ".")
		{
			sString  = PREFIX(sFileRegistryId,iTamanho);		
			sFileRegistryId = sString;
			iTamanho = 0;
		}
		else
		{
			iTamanho = iTamanho - 1;
		}
	}


	//Informacoes do sistema
	sEquipamentoEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP);
	if ( cgdc_trim(sEquipamentoEntrada, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sEquipamentoEntrada = gsEquipamentoEntrada;
	}

	sPortalEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL);
	if ( cgdc_trim(sPortalEntrada, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sPortalEntrada = gsPortalEntrada;
	}

	//Elemento de Rede
	//sElementoRede = sPortalEntrada;
	sElementoRede = CONCAT(sEquipamentoEntrada, "|", sPortalEntrada);

	//Regional
	sRegional = Irpt_GetRegional(sEquipamentoEntrada,sPortalEntrada,
			sInterfaceExterna);

	if (sRegional == "XX")
	{
		sRegional = "-3";
	}
			
	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;

	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;
	
	while ()
	{
		
    seqEnvDPM=seqEnvDPM+1;
		
		iReturn = container_find_next(rTransformacaoHdl, sContainerKey,
				rTransformacaoRec, giTransformacaoRecSize,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}

		if  ((sInterfaceExterna == "VOZ_MEDIAT_SUMM_v2")   || 
		     (sInterfaceExterna == "DADOS_MEDIAT_SUMM_v2") ||
		     (sInterfaceExterna == "TERC_MEDIAT_SUMM_v2"))
		{
			//--------------------------------------------------------------
			//Gera mensagem no DPM
			iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
					"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,ETAPA=%s,ORIGEM=%s,STATUS=%s,TIPO_CDR=%s,TIPO_ASSINANTE=%s,DATA_HR_EVENTO=%s,TOTAL_CDRS=%s,TOTAL_SEGUNDOS=%s,TOTAL_BYTES=%s,CENTRAL=%s,COD_ERRO=%s, SEQ_DPM=%04d",
					sFileRegistryId,
					sRegional,
					sElementoRede,
					sEtapa,
					sOrigem,
					rTransformacaoRec.STATUS,
					rTransformacaoRec.TIPO_CDR,
					rTransformacaoRec.TIPO_ASSINANTE,
					rTransformacaoRec.DATA_HR_EVENTO,
					rTransformacaoRec.TOTAL_CDRS,
					rTransformacaoRec.TOTAL_SEGUNDOS,
					rTransformacaoRec.TOTAL_BYTES,
					rTransformacaoRec.CENTRAL,
					rTransformacaoRec.COD_ERRO,
					seqEnvDPM);
		
			if (iReturnDPM != 0) // FALHA
			{
				break;
			}
		}
		else
		{
			//--------------------------------------------------------------
			//Gera mensagem no DPM
			iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
					"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,ETAPA=%s,ORIGEM=%s,STATUS=%s,TIPO_CDR=%s,TIPO_ASSINANTE=%s,DATA_HR_EVENTO=%s,TOTAL_CDRS=%s,TOTAL_SEGUNDOS=%s,TOTAL_BYTES=%s,CENTRAL=%s,COD_ERRO=%s, SEQ_DPM=%04d",
										sFileRegistryId,
										sRegional,
										sElementoRede,
										sEtapa,
										sOrigem,
										rTransformacaoRec.STATUS,
										rTransformacaoRec.TIPO_CDR,
										rTransformacaoRec.TIPO_ASSINANTE,
										rTransformacaoRec.DATA_HR_EVENTO,
										rTransformacaoRec.TOTAL_CDRS,
										rTransformacaoRec.TOTAL_SEGUNDOS,
										rTransformacaoRec.TOTAL_BYTES,
										"XX",
										"XX",
										seqEnvDPM);
		
			if (iReturnDPM != 0) // FALHA
			{
				break;
			}
		}

		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}

	}
	//return DCS_OPER_OK;
	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //End Irpt_GeraLogTransformacao


//******************************************************************************
//Procedure: Irpt_GeraLogTransfStage
//Objetivo:	Gera log com informacoes dos registros de arquivos submetidos a
//		processos de transformacao para o IRPT (Inter-mediatE Reporting),
//		atraves do DPM (Data Processing Message).
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaTransfStage para inicializar o container e
//		Irpt_SumarizaTransfStage, que sumariza num container as
//		informacoes dos registros.
//		Esta procedure deve estar presente nos scripts de transformacao e
//		invocada sempre depois do tratamento do ultimo registro de cada
//		arquivo.
//		Para isso, usa-se no INIT a instrucao "dcs_cgdc_term_processing"
//		para solicitar novo processamento apos ultimo registro e no MAIN
//		a instrucao "dcs_cgdc_get_integer_param(DCS_CGDC_LAST_CALL)"
//		para identificar ultima chamada de processamento.
//Entrada:	- sInterfaceExterna: identifica se eh "VOZ", "DADOS", "TERCEIROS".
//		- sEtapa: etapa do processamento, de acordo com definicao em
//			  tabela de fluxo de processos (3 caracteres).
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GeraLogTransfStage
(	string		sInterfaceExterna,
		string		sEtapa
) returns integer
{
	declare string		sEquipamentoEntrada;
	declare string		sPortalEntrada;
	declare string		sRegional;
	declare string		sElementoRede;
	declare string		sOrigem;
	declare integer		iFirstKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sContainerKey;
	declare string		sFileRegistryId;
	declare integer		iTamanho;
	declare string		sString;	
	declare integer		seqEnvDPM;

	iTamanho = 0;
	sString	 = "";
	
	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	sInterfaceExterna = TABLE(sInterfaceExterna)
	 {
		 "VOZ"				=> "STAGE_MEDIAT_SUMM";
		 "VOZ_v2","VOZ_V2"		=> "STAGE_MEDIAT_SUMM";
		 "DADOS"				=> "STAGE_MEDIAT_SUMM";
		 "TERCEIROS"			=> "STAGE_MEDIAT_SUMM";
		 "DADOS_v2","DADOS_V2"		=> "STAGE_MEDIAT_SUMM";
		// "DADOS"				=> "DADOS_MEDIAT_SUMM";
		// "DADOS_v2","DADOS_V2"		=> "DADOS_MEDIAT_SUMM_v2";
		// "TERCEIROS"			=> "TERC_MEDIAT_SUMM";
		// "TERCEIROS_v2","TERCEIROS_V2"	=> "TERC_MEDIAT_SUMM_v2";
		// "TCO"				=> "TERC_MEDIAT_SUMM";
		// "TFI"				=> "TERC_MEDIAT_SUMM";
		// "ROI"				=> "TERC_MEDIAT_SUMM";
		default => "STAGE_DUMMY";
	}
//	{
		//default => "STAGE_MEDIAT_SUMM";
//	}

	//Se 'etapa' tiver menos de 3 caracteres, acrescentar '0' a esquerda
	sEtapa = PadZeroEsq(sEtapa, 3);

	//Identificacao do arquivo de entrada no File Registry, interno ao Inter-mediatE.
	sFileRegistryId = dcs_cgdc_get_string_param(DCS_CGDC_FILENAME);
	
	if ( cgdc_trim(sFileRegistryId, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sFileRegistryId = gsFileRegistryId;
		sOrigem 	= "NORMAL";
	}
	else
	{
		//Determinacao da 'origem', ou seja, se o arquivo veio do fluxo normal,
		//se veio do EPS ou se foi 'aglutinado' pelo PRA.
		sOrigem = TABLE(dcs_cgdc_filreg_get_file_type(dcs_cgdc_get_string_param(DCS_CGDC_FILENAME)))
		{
			6	=> "EPS";
			7	=> "EPS";
			11	=> "ASSEMBLED";
			default	=> "NORMAL";
		}

        // 200912/22 - incluido para tratamento do import de registros exportados do eps
		if (sOrigem == "NORMAL" && prefix(suffix(dcs_cgdc_get_string_param(DCS_CGDC_EXT_FILENAME),7),3) == "EPS")
		{
		    sOrigem = "EPS";
		}		
		
	}

	sOrigem	= PREFIX(sOrigem, 1);

	//Patronizacao do File Registry Id
	iTamanho	    = sizeof(sFileRegistryId);
	sString		    = "";
	while (iTamanho > 0)
	{
		if (cgdc_substring(sFileRegistryId,iTamanho,1) == ".")
		{
			sString  = PREFIX(sFileRegistryId,iTamanho);		
			sFileRegistryId = sString;
			iTamanho = 0;
		}
		else
		{
			iTamanho = iTamanho - 1;
		}
	}


	//Informacoes do sistema
	sEquipamentoEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP);
	if ( cgdc_trim(sEquipamentoEntrada, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sEquipamentoEntrada = gsEquipamentoEntrada;
	}

	sPortalEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL);
	if ( cgdc_trim(sPortalEntrada, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sPortalEntrada = gsPortalEntrada;
	}

	//Elemento de Rede
	//sElementoRede = sPortalEntrada;
	sElementoRede = CONCAT(sEquipamentoEntrada, "|", sPortalEntrada);

	//Regional
	sRegional = Irpt_GetRegional(sEquipamentoEntrada,sPortalEntrada,
			sInterfaceExterna);

	if (sRegional == "XX")
	{
		sRegional = "-3";
	}

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;

	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;
	
	while ()
	{

		seqEnvDPM=seqEnvDPM+1;

		iReturn = container_find_next(rTransfStageHdl, sContainerKey,
				rTransfStageRec, giTransfStageRecSize,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}

		if  (sInterfaceExterna == "STAGE_MEDIAT_SUMM")
		{
			//--------------------------------------------------------------
			//Gera mensagem no DPM
			iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
					"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,ETAPA=%s,ORIGEM=%s,STATUS=%s,TIPO_CDR=%s,TIPO_ASSINANTE=%s,DATA_HR_EVENTO=%s,TOTAL_CDRS=%s,TOTAL_SEGUNDOS=%s,TOTAL_BYTES=%s,CENTRAL=%s,COD_ERRO=%s, CLASSIFICACAO=%s, SEQ_DPM=%04d",
					sFileRegistryId,
					sRegional,
					sElementoRede,
					sEtapa,
					sOrigem,
					rTransfStageRec.STATUS,
					rTransfStageRec.TIPO_CDR,
					rTransfStageRec.TIPO_ASSINANTE,
					rTransfStageRec.DATA_HR_EVENTO,
					rTransfStageRec.TOTAL_CDRS,
					rTransfStageRec.TOTAL_SEGUNDOS,
					rTransfStageRec.TOTAL_BYTES,
					rTransfStageRec.CENTRAL,
					rTransfStageRec.COD_ERRO,
					rTransfStageRec.CLASSIFICACAO,
					seqEnvDPM);
		
			if (iReturnDPM != 0) // FALHA
			{
				break;
			}
		}
		else
		{
			//--------------------------------------------------------------
			//Gera mensagem no DPM
			iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
					"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,ETAPA=%s,ORIGEM=%s,STATUS=%s,TIPO_CDR=%s,TIPO_ASSINANTE=%s,DATA_HR_EVENTO=%s,TOTAL_CDRS=%s,TOTAL_SEGUNDOS=%s,TOTAL_BYTES=%s,CENTRAL=%s,COD_ERRO=%s,CLASSIFICACAO=%s,SEQ_DPM=%04d",
										sFileRegistryId,
										sRegional,
										sElementoRede,
										sEtapa,
										sOrigem,
										rTransfStageRec.STATUS,
										rTransfStageRec.TIPO_CDR,
										rTransfStageRec.TIPO_ASSINANTE,
										rTransfStageRec.DATA_HR_EVENTO,
										rTransfStageRec.TOTAL_CDRS,
										rTransfStageRec.TOTAL_SEGUNDOS,
										rTransfStageRec.TOTAL_BYTES,
										"XX",
										"XX",
										rTransfStageRec.CLASSIFICACAO,
										seqEnvDPM);
		
			if (iReturnDPM != 0) // FALHA
			{
				break;
			}
		}

		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}

	}
	//return DCS_OPER_OK;
	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //End Irpt_GeraLogTransfStage


//******************************************************************************
//Procedure: Irpt_InicializaEntrada_Terceiros
//Objetivo:	Inicializa container "vivo_irpt_entrada_terceiros".
//		Esta procedure deve ser invocada apenas uma vez, no INIT do
//		script de estatistica de terceiros.
//Entrada:	Nao ha.
//Retorno:	1: inicializou com sucesso.
//		0: houve falha na inicializacao.
//******************************************************************************
procedure Irpt_InicializaEntrada_Terceiros() returns integer
{
	rEntradaTerceirosHdl = container_init();

	if ( rEntradaTerceirosHdl == MAP(0) ) //se nao inicializou
	{
		return 0;
	}

	ALLOCATE(rEntradaTerceirosRec);
	giEntradaTerceirosRecSize = sizeof(rEntradaTerceirosRec);

	return 1;

} //End Irpt_InicializaEntrada_Terceiros


//******************************************************************************
//Procedure: Irpt_SumarizaEntrada_Terceiros
//Objetivo:	Sumariza informacoes dos registros de arquivos de entrada de
//		terceiros para o IRPT (Inter-mediatE Reporting).
//		As informacoes sao carregadas num container previamente definido
//		para que possam ser sumarizadas de acordo com regras definidas
//		na especificacao de Relatorios Gerenciais.
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaEntrada_Terceiros para inicializar o container e
//		Irpt_GeraLogEntrada_Terceiros, onde as informacoes jah sumarizadas
//		do container servirao para gerar o log atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve estar presente nos scripts de estatistica e
//		invocada sempre no tratamento de cada registro do arquivo.
//Entrada:	- sNatureza: codigo de natureza da chamada.
//		- sOperVisitada: codigo EOT da operadora visitada pelo assinante.
//		- sTipoChamada: identifica se eh VC1, VC2, VC3, DSL1, DSL2...
//			TCO: se natureza for '099': 'tipo de chamada', demais
//			     casos: campo 'vc'.
//			TFI: "000".
//			ROI: campo 'categoria'.
//			EXI (retorno de erro TFI): campo 'identificacao do registro'.
//			EXA (retorno de erro ROI): campo 'tipo do registro'.
//		- sCodigoRejeicao: identifica o tipo da rejeicao (exclusao) da
//				   chamada pela Clearing House (CH).
//			TCO: se natureza for '099': 'codigo de exclusao'.
//			EXI: campo 'codigo exclusao chamadas internacionais'.
//			EXA: campo 'codigo rejeitado'.
//		- sDataProcPorTerceiro: data de processamento pelo elemento
//			"terceiro" (exemplo Clearing House). Vem especificado no
//			header do arquivo de entrada. Nao eh a data de processamento
//			do sistema de mediacao. (YYYYMMDD).
//			Como ha arquivos com mais de um header, eh necessario
//			passar este parametro a cada registro tratado.
//		- sDataHoraEvento: este parametro deve entrar no formato YYYYMMDDHHMMSS.
//		- sSegundos: duracao da chamada do registro em segundos:
//			TCO: campo 'duracao real da chamada'.
//			TFI e ROI: campo 'duracao da chamada'.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_SumarizaEntrada_Terceiros
(	string 		sNatureza,
		string		sOperVisitada,
		string 		sTipoChamada,
		string  	sCodigoRejeicao,
		string 		sDataProcPorTerceiro,
		string		sDataHoraEvento,
		string 		sSegundos
) returns integer
{
	declare integer		iSegundos;
	declare string		sContainerKey;
	declare integer 	iExiste;
	declare datetime_string	dtDataSistema;
	
	//Se 'natureza' for vazia, substituir
	if ( cgdc_trim(sNatureza, ' ', 0) == "" )
	{
		sNatureza = "XXX";
	}

	//Se 'operadora visitada' for vazia, substituir
	if ( cgdc_trim(sOperVisitada, ' ', 0) == "" )
	{
		sOperVisitada = "XXX";
	}

	//Se 'tipo da chamada' for vazio, substituir
	if ( cgdc_trim(sTipoChamada, ' ', 0) == "" )
	{
		sTipoChamada = "XXX";
	}

	//Se 'codigo de rejeicao' for vazio, substituir
	if ( cgdc_trim(sCodigoRejeicao, ' ', 0) == "" )
	{
		sCodigoRejeicao = "XXXX";
	}

	//Para sumarizar a entrada, a 'data de processamento por terceiro' deve
	//ter o formato YYYYMMDD.
	sDataProcPorTerceiro = PREFIX(sDataProcPorTerceiro, 8);

	//Se 'data de processamento' for vazia ou invalida, substituir por "99999999"
	if ( cgdc_trim(sDataProcPorTerceiro, ' ', 0) == "" || sizeof(sDataProcPorTerceiro) < 8 ||
			cgdc_isdigits(sDataProcPorTerceiro) == 0 )
	{
		sDataProcPorTerceiro = "99999999";
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataProcPorTerceiro, 17, '0')) != 0 )
	{
		sDataProcPorTerceiro = "99999999";
	}

	//Para sumarizar, a 'data/hora do evento' deve ter o formato YYYYMMDDHH
	sDataHoraEvento = PREFIX(sDataHoraEvento, 10);

	//Se 'data/hora do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataHoraEvento, ' ', 0) == "" || sizeof(sDataHoraEvento) < 10 ||
			cgdc_isdigits(sDataHoraEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataHoraEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataHoraEvento = PREFIX(dtDataSistema, 10);
	}

	//Verifica se parametro de entrada 'segundos' eh composto apenas de digitos
	if ( cgdc_isdigits(sSegundos) )
	{
		iSegundos = sSegundos;
	}
	else
	{
		iSegundos = 0;
	}

	//Monta chave do container
	sContainerKey = CONCAT (sNatureza, sOperVisitada, sTipoChamada, sCodigoRejeicao,
			sDataProcPorTerceiro, sDataHoraEvento);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
	iExiste = cgdc_container_get_or_add(rEntradaTerceirosHdl, sContainerKey,
			rEntradaTerceirosRec, giEntradaTerceirosRecSize);

	//Se ainda nao existe, inicializa campos do container
	if ( iExiste == 0 )
	{
		rEntradaTerceirosRec.NATUREZA        = sNatureza;
		rEntradaTerceirosRec.OPER_VISITADA   = sOperVisitada;
		rEntradaTerceirosRec.TIPO_CHAMADA    = sTipoChamada;
		rEntradaTerceirosRec.CODIGO_REJEICAO = sCodigoRejeicao;
		rEntradaTerceirosRec.DATA_PROC_TERC  = sDataProcPorTerceiro;
		rEntradaTerceirosRec.DATA_HR_EVENTO  = sDataHoraEvento;
		rEntradaTerceirosRec.TOTAL_CDRS      = 0;
		rEntradaTerceirosRec.TOTAL_SEGUNDOS  = 0;
	}

	//Incrementa contadores
	rEntradaTerceirosRec.TOTAL_CDRS     = rEntradaTerceirosRec.TOTAL_CDRS + 1;
	rEntradaTerceirosRec.TOTAL_SEGUNDOS = rEntradaTerceirosRec.TOTAL_SEGUNDOS + iSegundos;

	return DCS_OPER_OK;

} //End Irpt_SumarizaEntrada_Terceiros


//******************************************************************************
//Procedure: Irpt_GeraLogEntrada_Terceiros
//Objetivo:	Gera log com informacoes dos registros de arquivos de entrada
//		vindos de terceiros para o IRPT (Inter-mediatE Reporting),
//		atraves do DPM (Data Processing Message).
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaEntrada_Terceiros para inicializar o container e
//		Irpt_SumarizaEntrada_Terceiros, que sumariza num container as
//		informacoes dos registros.
//		Esta procedure deve estar presente nos scripts de estatistica e
//		invocada sempre depois do tratamento do ultimo registro de cada
//		arquivo.
//		Para isso, usa-se no INIT a instrucao "dcs_cgdc_term_processing"
//		para solicitar novo processamento apos ultimo registro e no MAIN
//		a instrucao "dcs_cgdc_get_integer_param(DCS_CGDC_LAST_CALL)"
//		para identificar ultima chamada.
//Entrada:	- sInterfaceExterna: "TERCEIROS".
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GeraLogEntrada_Terceiros
(	string		sInterfaceExterna
) returns integer
{
	declare string		sEquipamentoEntrada;
	declare string		sPortalEntrada;
	declare string		sRegional;
	declare string		sElementoRede;
	declare string		sArquivoEntrada;
	declare string		sFileRegistryId;
	declare datetime_string	dtDataColeta;
	declare string		sDataColeta;
	declare integer		iFirstKey;
	declare string		sContainerKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sOrigem;
	declare integer		iTamanho;
	declare string		sString;
	declare integer		seqEnvDPM;

	iTamanho = 0;
	sString  = "";
	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	sInterfaceExterna = TABLE(sInterfaceExterna)
	{
		"TERCEIROS" => "TERC_INPUT_SUMM";
		"TCO" 	    => "TERC_INPUT_SUMM";
		"TFI" 	    => "TERC_INPUT_SUMM";
		"ROI" 	    => "TERC_INPUT_SUMM";
		default => SAME;
	}

	//Informacoes do sistema
	sEquipamentoEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP);
	sPortalEntrada      = dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL);
	sArquivoEntrada     = dcs_cgdc_get_string_param(DCS_CGDC_EXT_FILENAME);  //master file
	sFileRegistryId     = dcs_cgdc_get_string_param(DCS_CGDC_FILENAME);
	dtDataColeta        = dcs_cgdc_get_datetime_param(DCS_CGDC_COLLECT_TIME);
	sDataColeta         = PREFIX(dtDataColeta, 8);  //YYYYMMDD

	if ( cgdc_trim(sFileRegistryId, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sOrigem = "NORMAL";
	}
	else
	{
		//Se o registro veio do EPS (origem EPS), nao se deve gerar o log de
		//entrada, pois o log deste registro jah foi anteriormente gerado,
		//quando foi enviado a primeira vez ao EPS (com origem NORMAL).
		//Assim, evita-se contar o mesmo registro mais de uma vez quando ele
		//sair do EPS e voltar ao plano de processamento.
		sOrigem = TABLE(dcs_cgdc_filreg_get_file_type(dcs_cgdc_get_string_param(DCS_CGDC_FILENAME)))
		{
			6	=> "EPS";
			7	=> "EPS";
			11	=> "ASSEMBLED";
			default	=> "NORMAL";
		}
		
		// // 200912/22 - incluido para tratamento do import de registros exportados do eps
		if (sOrigem == "NORMAL" && prefix(suffix(sArquivoEntrada,7),3) == "EPS")
		{
		    sOrigem = "EPS";
		}		
		
	}

	//Patronizacao do File Registry Id
	iTamanho	    = sizeof(sFileRegistryId);
	sString		    = "";
	while (iTamanho > 0)
	{
		if (cgdc_substring(sFileRegistryId,iTamanho,1) == ".")
		{
			sString  = PREFIX(sFileRegistryId,iTamanho);		
			sFileRegistryId = sString;
			iTamanho = 0;
		}
		else
		{
			iTamanho = iTamanho - 1;
		}
	}
	
	if (sOrigem == "EPS")
	{
		//return DCS_OPER_OK;
		return 0;
	}




	//Se 'arquivo de entrada' vazio, substitui.
	if ( cgdc_trim(sArquivoEntrada, ' ', 0) == "" )
	{
		//sArquivoEntrada = "NAME_NOT_FOUND";
		sArquivoEntrada = sFileRegistryId;
	}

	//Elemento de Rede
	//sElementoRede = sPortalEntrada;
	sElementoRede = CONCAT(sEquipamentoEntrada, "|", sPortalEntrada);

	//Regional
	sRegional = Irpt_GetRegional(sEquipamentoEntrada,sPortalEntrada,sInterfaceExterna);

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;

	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;

	while ()
	{

    seqEnvDPM=seqEnvDPM+1;

		iReturn = container_find_next(rEntradaTerceirosHdl, sContainerKey,
				rEntradaTerceirosRec, giEntradaTerceirosRecSize,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}

		//--------------------------------------------------------------
		//Gera mensagem no DPM
		iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
				"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,ARQUIVO_ENTRADA=%s,DATA_COLETA=%s,DATA_HR_EVENTO=%s,DATA_PROC_TERC=%s,NATUREZA=%s,OPER_VISITADA=%s,TIPO_CHAMADA=%s,CODIGO_REJEICAO=%s,TOTAL_CDRS=%s,TOTAL_SEGUNDOS=%s, SEQ_DPM=%04d",
				sFileRegistryId,
				sRegional,
				sElementoRede,
				sArquivoEntrada,
				sDataColeta,
				rEntradaTerceirosRec.DATA_HR_EVENTO,
				rEntradaTerceirosRec.DATA_PROC_TERC,
				rEntradaTerceirosRec.NATUREZA,
				rEntradaTerceirosRec.OPER_VISITADA,
				rEntradaTerceirosRec.TIPO_CHAMADA,
				rEntradaTerceirosRec.CODIGO_REJEICAO,
				rEntradaTerceirosRec.TOTAL_CDRS,
				rEntradaTerceirosRec.TOTAL_SEGUNDOS,
				seqEnvDPM);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}

		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}


	}

	//return DCS_OPER_OK;
	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //End Irpt_GeraLogEntrada_Terceiros


//******************************************************************************
//Procedure: Irpt_InicializaSaida_Terceiros
//Objetivo:	Inicializa container "vivo_irpt_saida_terceiros".
//		Esta procedure deve ser invocada apenas uma vez, no INIT do
//		script de saida.
//Entrada:	Nao ha.
//Retorno:	1: inicializou com sucesso.
//		0: houve falha na inicializacao.
//******************************************************************************
procedure Irpt_InicializaSaida_Terceiros() returns integer
{
	Irpt_InicializaSaida_Stage();

	rSaidaTerceirosHdl = container_init();

	if ( rSaidaTerceirosHdl == MAP(0) ) //se nao inicializou
	{
		return 0;
	}

	ALLOCATE(rSaidaTerceirosRec);
	giSaidaTerceirosRecSize = sizeof(rSaidaTerceirosRec);

	return 1;

} //End Irpt_InicializaSaida_Terceiros


//******************************************************************************
//Procedure: Irpt_SumarizaSaida_Terceiros
//Objetivo:	Sumariza informacoes dos registros de arquivos de saida
//		(terceiros) para o IRPT (Inter-mediatE Reporting).
//		As informacoes sao carregadas num container previamente definido
//		para que possam ser sumarizadas de acordo com regras definidas
//		na especificacao de Relatorios Gerenciais.
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaSaida_Terceiros para inicializar o container e
//		Irpt_GeraLogSaida_Terceiros, onde as informacoes jah sumarizadas
//		do container servirao para gerar o log atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve estar presente nos scripts de saida e
//		invocada sempre no tratamento de cada registro do arquivo.
//		Regional e Elemento de Rede devem ser atualizados no script de
//		saida a cada novo arquivo de entrada. Isso ocorre pois o script
//		de saida pode juntar varios arquivos de entrada para formar um
//		unico batch de saida.
//Entrada:	- sRegional.
//		- sElementoRede: equipamento_entrada|portal_entrada, ou
//				 equipamento_entrada|portal_entrada|file_id.
//		- sDataEvento: data da chamada.
//		- sIdentRegistro: identificacao do tipo do registro, se DDD, ACB,
//				  local, deslocamento, DLC, chamada valorada, etc.
//		- sAreaNumeroA: codigo de area no assinante A, compor com as duas
//				primeiras posicoes do numero de A.
//		- sSegundos: duracao da chamada do registro.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_SumarizaSaida_Terceiros
(	string 		sRegional,
		string 		sElementoRede,
		string		sDataEvento,
		string		sIdentRegistro,
		string		sAreaNumeroA,
		string		sSegundos
) returns integer
{
	declare datetime_string	dtDataSistema;
	// Walter Fonseca - Chamado  20525185 inicio
	declare unsigned long	integer	iSegundos; // - estouro do campo integer
	// Walter Fonseca - Chamado 20525185 fim
	declare string		sContainerKey;
	declare integer 	iExiste;

	Irpt_SumarizaSaida_Stage
	(
		sRegional,
		sElementoRede,
		sDataEvento
	);

	//Verifica 'regional'
	if ( cgdc_trim(sRegional, ' ', 0) == "" )
	{
		sRegional = "XX";
	}

	//Verifica 'elemento de rede'. Este parametro pode vir sendo composto das
	//seguintes maneiras: equipamento_entrada|portal_entrada, ou
	//equipamento_entrada|portal_entrada|file_id, sendo file_id o nome do
	//arquivo derivado.
	if ( cgdc_trim(sElementoRede, ' ', 0) == "" )
	{
		sElementoRede = "XXX";
	}

	//Para sumarizar a saida, a 'data do evento' deve ter o formato YYYYMMDD
	sDataEvento = PREFIX(sDataEvento, 8);

	//Se 'data do evento' for vazia ou invalida, substituir pela
	//data do sistema.
	if ( cgdc_trim(sDataEvento, ' ', 0) == "" || sizeof(sDataEvento) < 8 ||
			cgdc_isdigits(sDataEvento) == 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataEvento = PREFIX(dtDataSistema, 8);
	}
	else if ( cgdc_validate_datetime_str(cgdc_pad(sDataEvento, 17, '0')) != 0 )
	{
		dtDataSistema = cgdc_get_local_time();
		sDataEvento = PREFIX(dtDataSistema, 8);
	}

	//Se parametros de entrada 'identificacao de registro' e
	//'codigo de area de A' forem vazios, substituir.
	if ( cgdc_trim(sIdentRegistro, ' ', 0) == "" )
	{
		sIdentRegistro = "X";
	}
	if ( cgdc_trim(sAreaNumeroA, ' ', 0) == "" )
	{
		sAreaNumeroA = "XX";
	}

	//Verifica se parametro de entrada 'segundos' eh composto apenas de digitos
	if ( cgdc_isdigits(sSegundos) )
	{
		iSegundos = sSegundos;
	}
	else
	{
		iSegundos = 0;
	}	

	//Monta chave do container
	sContainerKey = CONCAT(sRegional, sElementoRede, sDataEvento,
			sIdentRegistro, sAreaNumeroA);

	//Pergunta se a chave jah existe, se nao, eh carregada automaticamente
	iExiste = cgdc_container_get_or_add(rSaidaTerceirosHdl, sContainerKey,
			rSaidaTerceirosRec, giSaidaTerceirosRecSize);

	//Se ainda nao existe, inicializa campos do container
	if ( iExiste == 0 )
	{
		rSaidaTerceirosRec.REGIONAL        = sRegional;
		rSaidaTerceirosRec.ELEMENTO_REDE   = sElementoRede;
		rSaidaTerceirosRec.DATA_EVENTO     = sDataEvento;
		rSaidaTerceirosRec.IDENT_REGISTRO  = sIdentRegistro;
		rSaidaTerceirosRec.AREA_NUMERO_A   = sAreaNumeroA;
		rSaidaTerceirosRec.TOTAL_CDRS      = 0;
		rSaidaTerceirosRec.TOTAL_SEGUNDOS  = 0;
	}

	//Incrementa contador
	rSaidaTerceirosRec.TOTAL_CDRS     = rSaidaTerceirosRec.TOTAL_CDRS + 1;
	rSaidaTerceirosRec.TOTAL_SEGUNDOS = rSaidaTerceirosRec.TOTAL_SEGUNDOS + iSegundos;

	return DCS_OPER_OK;

} //End Irpt_SumarizaSaida_Terceiros


//******************************************************************************
//Procedure: Irpt_GeraLogSaida_VozDados
//Objetivo:	Gera log com informacoes de arquivos de saida (terceiros)
//		para o IRPT (Inter-mediatE Reporting), atraves do DPM (Data
//		Processing Message).
//		Esta procedure deve ser usada em conjunto com as procedures
//		Irpt_InicializaSaida_Terceiros para inicializar o container e
//		Irpt_SumarizaSaida_Terceiros, que sumariza num container as
//		informacoes dos registros.
//		Esta procedure deve estar presente nos scripts de saida e
//		invocada sempre depois do tratamento do ultimo registro de cada
//		arquivo.
//		Para isso, usa-se no INIT a instrucao "dcs_cgdc_term_processing"
//		para solicitar novo processamento apos ultimo registro e no MAIN
//		a instrucao "dcs_cgdc_get_integer_param(DCS_CGDC_LAST_CALL)"
//		para identificar ultima chamada.
//Entrada:	- sInterfaceExterna: "TERCEIROS".
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GeraLogSaida_Terceiros
(	string		sInterfaceExterna
) returns integer
{
	declare string		sDestino;
	declare datetime_string dtDataEntrega;
	declare string		sDataEntrega;
	declare string		sArquivoSaida;
	declare integer		iFirstKey;
	declare integer		iReturn;
	declare integer		iReturnDPM;
	declare string		sContainerKey;
	declare string		sElementoRede;
	declare string		sFileRegistryId;
	declare integer		iOffset;
	declare integer		iFirstPipeFound;
	declare integer		iTamanho;
	declare string		sString;
	declare integer		seqEnvDPM;

	iTamanho	    = 0;
	sString		    = "";

	//Se for um RECUT, nao gerar log, pois ele jah foi gerado na primeira vez
	//que o arquivo de saida foi criado.
	if (dcs_cgdc_get_string_param(DCS_CGDC_OUTP_CUT_TYPE) == "R")
	{
		//return DCS_OPER_OK;
		return 0;
	}

	Irpt_GeraLogSaida_Stage(sInterfaceExterna);
	
	//A 'interface externa' deve ter seu conteudo alterado para o codigo
	//esperado pelo sistema de Relatorios Gerencias
	sInterfaceExterna = TABLE(sInterfaceExterna)
	{
		"TERCEIROS"	=> "TERC_OUTPUT_SUMM";
		"DADOS"     => "DADOS_OUTPUT_SUMM";//Adicionado conforme d27422
		"VOZ"				=> "VOZ_OUTPUT_SUMM";// Adicionado conforme c20792617
		default 	=> SAME;
	}

	//O 'destino' deve ser o portal de saida no Inter-mediatE
	//sDestino = dcs_cgdc_get_string_param(DCS_CGDC_OUTP_DATA_PORTAL);
	sDestino = CONCAT(dcs_cgdc_get_string_param(DCS_CGDC_OUTP_EXT_EQUIP),"|",dcs_cgdc_get_string_param(DCS_CGDC_OUTP_DATA_PORTAL));

	//Nome do arquivo de saida, do arquivo batch a ser formado
	sArquivoSaida = dcs_cgdc_get_string_param(DCS_CGDC_OUTP_EXT_FILENAME);

	//A 'data de entrega do arquivo' serah a data do sistema
	dtDataEntrega = cgdc_get_local_time();
	sDataEntrega = PREFIX(dtDataEntrega, 8);  //YYYYMMDD

	// Inicializa retorno do DPM como FALHA
	iReturnDPM = -1;

	//Para cada chave do container deve-se gerar mensagem no DPM
	iFirstKey = 1;

	//Sequencial de contrele de envio dos registros para o DPM
	seqEnvDPM = 0;

	while ()
	{

    		seqEnvDPM=seqEnvDPM+1;

		iReturn = container_find_next(rSaidaTerceirosHdl, sContainerKey,
				rSaidaTerceirosRec, giSaidaTerceirosRecSize,
				iFirstKey);
		if ( iReturn == 0 )
		{
			break;  //Nao ha mais chaves, sai do while
		}
		else
		{
			iFirstKey = 0;
		}

		// Sergio Fernandes, 2005-03-16.
		// Separa a informacao de 'file_id' de dentro do campo
		// ELEMENTO_REDE, este campo pode estar preenchido das seguintes
		// maneiras: equipamento_entrada|portal_entrada, ou
		// equipamento_entrada|portal_entrada|file_id. Assim, identifica-se
		// procurando pelo segundo "|" (pipe).
		iOffset = 0;
		iFirstPipeFound = 0;
		sElementoRede = rSaidaTerceirosRec.ELEMENTO_REDE;
		sFileRegistryId = "X";
		// Ultimo byte de uma variavel string eh sempre byte zero (NULL)
		while ( BYTE(sElementoRede, iOffset) != 0x00 )
		{
			if ( BYTE(sElementoRede, iOffset) == '|' )
			{
				if ( iFirstPipeFound == 0 )
				{
					// Achei apenas o primeiro "|" (pipe).
					iFirstPipeFound = 1;
				}
				else
				{
					// Entao ha informacao de 'file registry id'.
					sElementoRede = cgdc_substring(rSaidaTerceirosRec.ELEMENTO_REDE,0,iOffset);
					sFileRegistryId = cgdc_substring(rSaidaTerceirosRec.ELEMENTO_REDE,iOffset+1,-1);
					break;
				}
			}
			iOffset = iOffset + 1;
		}

		// Verifica se 'elemento de rede' estah vazio.
		if ( cgdc_trim(sElementoRede,' ',0) == "" )
		{
			sElementoRede = "XXX";
		}

		// Verifica se 'file id' estah vazio.
		if ( cgdc_trim(sFileRegistryId,' ',0) == "" )
		{
			sFileRegistryId = "X";
		}

		//Patronizacao do File Registry Id
		iTamanho	    = sizeof(sFileRegistryId);
		sString		    = "";
		while (iTamanho > 0)
		{
			if (cgdc_substring(sFileRegistryId,iTamanho,1) == ".")
			{
				sString  = PREFIX(sFileRegistryId,iTamanho);		
				sFileRegistryId = sString;
				iTamanho = 0;
			}
			else
			{
				iTamanho = iTamanho - 1;
			}
		}

		//--------------------------------------------------------------
		//Gera mensagem no DPM
		iReturnDPM = dcs_cgdc_dpm_put(sInterfaceExterna,
				"FILE_ID=%s,REGIONAL=%s,ELEMENTO_REDE=%s,DESTINO=%s,DATA_ENTREGA=%s,ARQUIVO_SAIDA=%s,DATA_EVENTO=%s,IDENT_REGISTRO=%s,AREA_NUMERO_A=%s,TOTAL_CDRS=%s,TOTAL_SEGUNDOS=%s, SEQ_DPM=%04d",
				sFileRegistryId,
				rSaidaTerceirosRec.REGIONAL,
				sElementoRede,
				sDestino,
				sDataEntrega,
				sArquivoSaida,
				rSaidaTerceirosRec.DATA_EVENTO,
				rSaidaTerceirosRec.IDENT_REGISTRO,
				rSaidaTerceirosRec.AREA_NUMERO_A,
				rSaidaTerceirosRec.TOTAL_CDRS,
				rSaidaTerceirosRec.TOTAL_SEGUNDOS,
				seqEnvDPM);
		
		if (iReturnDPM != 0) // FALHA
		{
			break;
		}

		if (seqEnvDPM >= 9999) // Limite Contador
		{
		   seqEnvDPM=0;
		}
		
	}

	//return DCS_OPER_OK;
	if (iReturn == 0 && iFirstKey == 1) //container vazio, situacao esperada
	{
		return 0;
	}
	else
	{
		// 2010/05/26 11:11:01  rsato
		// Falha no envio das Mensagens para o DPM		
		if (iReturnDPM != 0 )
		{
			cgdc_puterr ("GREGXENDITALL", "Can't process DPM Messages - script will be aborted");
$$
cgdc_abort (CGDC_STATUS_SYSERR);
$$
		}
		else
		{
			return iReturnDPM;
		}	
  }	

} //End Irpt_GeraLogSaida_Terceiros


//******************************************************************************
//Procedure: Irpt_GetRegional
//Objetivo:	Busca a regional na tabela de Relacao Portal x Central
//		("vivo_tab_portal_central").
//		Metodo antigo:
//		- Para os primeiros planos (planos 'online'), a regional deve ser
//		tomada pelo equipamento.
//		- Para os segundos planos (planos 'batch'), a regional deve ser
//		tomada pelo portal.
//		Verifica-se se eh plano 'online' ou 'batch' pelo nome do
//		equipamento.
//Entrada:	- sEquipamentoEntrada.
//		- sPortalEntrada.
//		- sInterfaceExterna: se nao usar esta procedure com o IRPT, deixar
//				     em branco ou nulo ("").
//Retorno:  	Regional (string).
//******************************************************************************
procedure Irpt_GetRegional
(	string	sEquipamentoEntrada,
		string	sPortalEntrada,
		string	sInterfaceExterna
) returns string
{
	declare integer iStatus;

	if(InicializarVivoTabPortalCentral() == DCS_OPER_ABORT)
	{
		cgdc_puterr("TBL_UNIN", "%s|%s [%s:%d] Tabela Portal Central nao inicializada",
						sEquipamentoEntrada, sPortalEntrada,
						$scriptname, $linenumber);
		DCS_RETURN_ABORT;
	}

	//Busca Regional na tabela de Relacao Portal x Central
	rec_PortalCentral.SYSTEM = sEquipamentoEntrada;
	rec_PortalCentral.PORTAL = sPortalEntrada;
	iStatus = reference_get (hdl_PortalCentral, rec_PortalCentral, CGDC_REFERENCE_EQUAL);
	if (!iStatus)
	{
		cgdc_puterr("PORTALNCAD", "%s|%s [%s:%d] Portal nao cadastrado",
				sEquipamentoEntrada, sPortalEntrada,
				$scriptname, $linenumber);
		DCS_RETURN_ABORT;

		//Metodo antigo de se buscar a Regional
		//		if ( PREFIX(sEquipamentoEntrada,4) == "FCDR" ||
		//		     PREFIX(sEquipamentoEntrada,4) == "MCDR" ||
		//		     PREFIX(sEquipamentoEntrada,4) == "TIDR" ||
		//		     PREFIX(sEquipamentoEntrada,3) == "RSR" )
		//		     //PREFIX(sInterfaceExterna,4) == "TERC" )  //processamento de terceiros
		//		{
		//			return (PREFIX(sPortalEntrada,2)); //plano 'batch'
		//		}
		//		else
		//		{
		//			return (PREFIX(sEquipamentoEntrada,2)); //plano 'online'
		//		}
	}
	else  //achou na tabela!
	{
		return (rec_PortalCentral.REGIONAL);
	}

} //End Irpt_GetRegional


//******************************************************************************
//Procedure: Irpt_GetStringParams
//Objetivo:	Esta funcao eh usada unicamente nos scripts de output de DRD.
//		No script 'vivo_common_procedures', quando chamado de um script
//		de output, nao se consegue obter os parametros se sistema
//		"Input External Equipment", "Input Data Portal" e "File Registry Id".
//		Portanto, usa-se esta funcao para inserir tais parametros como
//		variaveis estaticas (globais).
//Entrada:	- sEquipamentoEntrada.
//		- sPortalEntrada.
//		- sFileRegistryId.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Irpt_GetStringParams
(	string	sEquipamentoEntrada,
		string	sPortalEntrada,
		string	sFileRegistryId
) returns integer
{
	declare integer iTamanho;
	declare string  sString;
	
	iTamanho = 0;
	sString  = "";
	
	if ( sEquipamentoEntrada != "" )
	{
		gsEquipamentoEntrada = sEquipamentoEntrada;
	}
	else
	{
		gsEquipamentoEntrada = "NOT_FOUND";
	}

	if ( sPortalEntrada != "" )
	{
		gsPortalEntrada = sPortalEntrada;
	}
	else
	{
		gsPortalEntrada = "NOT_FOUND";
	}

	if ( sFileRegistryId != "" )
	{
		gsFileRegistryId = sFileRegistryId;
	}
	else
	{
		gsFileRegistryId = "NOT_FOUND";
	}
	
	//Patronizacao do File Registry Id
	iTamanho	    = sizeof(gsFileRegistryId);
	sString		    = "";
	while (iTamanho > 0)
	{
		if (cgdc_substring(gsFileRegistryId,iTamanho,1) == ".")
		{
			sString  = PREFIX(gsFileRegistryId,iTamanho);		
			gsFileRegistryId = sString;
			iTamanho = 0;
		}
		else
		{
			iTamanho = iTamanho - 1;
		}
	}
	
	return DCS_OPER_OK;

} //End Irpt_GetStringParams


//******************************************************************************
//Procedure: Mensagens_EPS
//Objetivo:	Funcao usada para gerar mensagens identificando os registros
//		enviados para o EPS. O DPM irá sumarizar os dados e criar relatórios,
//		alarmes.
//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure Mensagens_EPS
(
		string sCod,
		string sIdent
) returns integer
{
	declare string 		sDpmHeader;
	declare integer 	iStatus;
	declare string		sEquipamentoEntrada;
	declare string		sPortalEntrada;
	declare string		sRegional;
	declare string		sElementoRede;
	declare string		sFileRegistryId;
	declare	string		sInterfaceExterna;

	//Informacoes do sistema
	sEquipamentoEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP);
	if ( cgdc_trim(sEquipamentoEntrada, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sEquipamentoEntrada = gsEquipamentoEntrada;
	}

	sPortalEntrada = dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL);
	if ( cgdc_trim(sPortalEntrada, ' ', 0) == "" )
	{
		//Usa-se variavel estatica (global) definida pela funcao Irpt_GetStringParams
		sPortalEntrada = gsPortalEntrada;
	}

	//Elemento de Rede
	//sElementoRede = sPortalEntrada;
	sElementoRede = CONCAT(sEquipamentoEntrada, "|", sPortalEntrada);

	//Regional
	sInterfaceExterna  = "DPM_EPS";
	sRegional = Irpt_GetRegional(sEquipamentoEntrada,sPortalEntrada,sInterfaceExterna);

	// "NOME_ARQ_BIR" informação contém a sigla da regional, isto foi usado para não mexer na estrutura antiga, o envio do relatorio de eps via email
	// "REGIONAL" informação contém  o system portal e "NE" portal de coleta, isto foi usado para não mexer na estrutura antiga, o envio do relatorio de eps via email
	// "NOME_ARQ_ORIG" informação contém a sigla do file_registry, isto foi usado para não mexer na estrutura antiga, o envio do relatorio de eps via email
	sDpmHeader = FORMAT ( "REGIONAL=%s,ELEMENTO_REDE=%s,",sRegional,CONCAT(sEquipamentoEntrada,"|",sPortalEntrada));

	if ( cgdc_trim(sCod, ' ', 0) == "" )
	{
		sCod = "X";
	}

	if ( cgdc_trim(sIdent, ' ', 0) == "" )
	{
		sIdent = "X";
	}

	sDpmHeader = CONCAT ( sDpmHeader, FORMAT ( "COD_CRITICA=%s,DES_CRITICA=%s",sCod, sIdent ) );

	//Manda Mensagem DPM
	iStatus = dcs_cgdc_dpm_put ( "DPM_EPS", "%s", sDpmHeader );
	
	return iStatus;
}


//******************************************************************************
//Procedure: DestCriticas
//Objetivo:	Funcao usada para identificar se um registro deve ser enviado para
//		o EPS ( R - Rejectted, S - Suspense), arquivo ASCII, descartado ou
//		gerar alarmes

//Retorno:  	DCS_OPER_OK (integer).
//******************************************************************************
procedure DestCriticas
(
		string sCod,
		string ref sdest,
		integer ref ialarme
) returns integer
{
	declare integer iStatus;

	if ( hdlTabCriticas == MAP(0) )
	{
		hdlTabCriticas = reference_open("vivo_tab_dest_criticas");
		if ( hdlTabCriticas == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_dest_criticas");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rTabCriticas);
	}
	
	CLEAR(rTabCriticas);

	rTabCriticas.codigo = sCod;
	iStatus = reference_get (hdlTabCriticas, rTabCriticas, CGDC_REFERENCE_EQUAL);

	if (!iStatus)
	{
		rTabCriticas.codigo = "999";
		iStatus = reference_get (hdlTabCriticas, rTabCriticas, CGDC_REFERENCE_EQUAL);
		if (!iStatus)
		{
			sdest = "S";
			ialarme = 1;
			return FALSE;
		}
		else
		{
			sdest   = rTabCriticas.destino;
			ialarme = rTabCriticas.alarme;
			return FALSE;
		}
	}
	else
	{
		sdest   = rTabCriticas.destino;
		ialarme = rTabCriticas.alarme;
		return TRUE;
	}
}





//******************************************************************************
//Procedure: GetTabRecMin
//Objetivo:	Funcao usada na carga de tabelas. Devolve o numero minimo de
//              registros esperados para a tabela (no minimo esta funcao devolve 1)
//
procedure GetTabRecMin( string Portal ) returns integer
{

	declare  integer iStatus ;
	declare  integer NumRegMin;
	declare static record "reference_table"   vivo_tab_controle;
	declare static record "vivo_tab_carga_controle_rec"  tab_controle_rec;


	NumRegMin= 1;
	if( vivo_tab_controle == MAP(0) )
	{
		vivo_tab_controle = reference_init( "vivo_tab_carga_controle" );
		allocate( tab_controle_rec );
	}

	tab_controle_rec.PORTAL= Portal ;

	iStatus = reference_get( vivo_tab_controle, tab_controle_rec, CGDC_REFERENCE_EQUAL);
	if( iStatus == 1 )
	{
		NumRegMin= tab_controle_rec.NUM_MIN_REG  ;
		if ( NumRegMin == 0 )  //arquivos com zero registros nao sao aceitos
			NumRegMin= 1;
	}

	return NumRegMin ;
}


//******************************************************************************
//Procedure: SetTabControl_OK
//Objetivo:	Funcao usada para atualizar o status da tabela de status de carga (vivo_tab_carga_status).
//              Ela eh utilizada quando uma carga ocorreu com sucesso
//
procedure SetTabControl_OK( string Portal, integer TotReg, integer DupReg, integer CargaReg ) returns integer
{
	declare integer status    ;
	declare string data       ;
	declare string hora       ;
	declare datetime_string  dtAtual;
	declare static record "reference_table"   vivo_tab_status;
	declare static record "vivo_tab_carga_status_rec"  tab_status_rec;

	dtAtual = dcs_cgdc_get_datetime_param(DCS_CGDC_CURRENT_TIME);

	data = PREFIX( dtAtual, 8 ) ;
	hora = SUFFIX(PREFIX( dtAtual, 14 ),6) ;

	if (vivo_tab_status == MAP(0))
	{
		vivo_tab_status = reference_init_db( "vivo_tab_carga_status" );
		allocate( tab_status_rec );
	}

	tab_status_rec.PORTAL= Portal ;

	if ( reference_get_db( vivo_tab_status, tab_status_rec, CGDC_REFERENCE_EQUAL, 1 ) == 0 )
	{

		tab_status_rec.PORTAL= Portal ;
		tab_status_rec.REG_TOTAL= TotReg ;
		tab_status_rec.REG_DUPL= DupReg ;
		tab_status_rec.REG_CARGA= CargaReg ;
		tab_status_rec.DATA_ULT_CARGA= data ;
		tab_status_rec.HORA_ULT_CARGA= hora ;
		tab_status_rec.DATA_ULT_ERRO= "" ;
		tab_status_rec.HORA_ULT_ERRO= "" ;
		tab_status_rec.DESCR_ULT_ERRO= "" ;

		status = reference_add_db (vivo_tab_status, tab_status_rec);

		if ( status == 0 )
			return 0 ;
		else
			return 1 ;

	}
	else
	{
		tab_status_rec.PORTAL= Portal ;
		tab_status_rec.REG_TOTAL= TotReg ;
		tab_status_rec.REG_DUPL= DupReg ;
		tab_status_rec.REG_CARGA= CargaReg ;
		tab_status_rec.DATA_ULT_CARGA= data ;
		tab_status_rec.HORA_ULT_CARGA= hora ;
		status = reference_upd_db (vivo_tab_status, tab_status_rec);
		if ( status == 0 )
			return 0 ;
		else
			return 1 ;

	}

	return 0;

}

//******************************************************************************
//Procedure: SetTabControl_Error
//Objetivo:	Funcao usada para atualizar o status da tabela de status de carga (vivo_tab_carga_status).
//              Ela eh utilizada quando uma carga ocorreu com erro
//
procedure SetTabControl_Error( string Portal, string Descr ) returns integer
{
	declare integer status    ;
	declare string data       ;
	declare string hora       ;
	declare datetime_string  dtAtual;
	declare static record "reference_table"   vivo_tab_status;
	declare static record "vivo_tab_carga_status_rec"  tab_status_rec;

	dtAtual = dcs_cgdc_get_datetime_param(DCS_CGDC_CURRENT_TIME);

	data = PREFIX( dtAtual, 8 ) ;
	hora = SUFFIX(PREFIX( dtAtual, 14 ),6) ;


	if (vivo_tab_status == MAP(0))
	{
		vivo_tab_status = reference_init_db( "vivo_tab_carga_status" );
		allocate( tab_status_rec );
	}

	tab_status_rec.PORTAL= Portal ;

	if ( reference_get_db( vivo_tab_status, tab_status_rec, CGDC_REFERENCE_EQUAL, 1 ) == 0 )
	{

		tab_status_rec.PORTAL= Portal ;
		tab_status_rec.DATA_ULT_ERRO= data ;
		tab_status_rec.HORA_ULT_ERRO= hora ;
		tab_status_rec.DESCR_ULT_ERRO= Descr ;
		tab_status_rec.REG_TOTAL= 0 ;
		tab_status_rec.REG_DUPL= 0 ;
		tab_status_rec.REG_CARGA= 0 ;
		tab_status_rec.DATA_ULT_CARGA= "" ;
		tab_status_rec.HORA_ULT_CARGA= "" ;

		status = reference_add_db (vivo_tab_status, tab_status_rec);

		if ( status == 0 )
			return 0 ;
		else
			return 1 ;

	}
	else
	{
		tab_status_rec.DATA_ULT_ERRO= data ;
		tab_status_rec.HORA_ULT_ERRO= hora ;
		tab_status_rec.DESCR_ULT_ERRO= Descr ;
		status = reference_upd_db (vivo_tab_status, tab_status_rec);
		if ( status == 0 )
			return 0 ;
		else
			return 1 ;

	}

	return 0;
}


//******************************************************************************
//Procedure: MakeOffset
//Objetivo:  Retorna um string que contem a identificacao unica do arquivo
//           de CDRs Brutos. Este valor constara no nome do arquivo de Backup
//           e em cada FCDR gerado a partir deste arquivo
//
//           Offset: YMXXXXXXX,
//           onde: Y: sao os dois ultimos digitos do ano convertido para Hexa
//                 M: e o mes convertido para Hexa
//             XXXXX: n. seq. do Internal FileName (convertido para Hexa)
//
procedure MakeOffset( ) returns string
{
	declare string 		sOffset;
	declare	integer		iSeq;
	declare integer		iYear;
	declare integer		iMonth;
	declare string		sFilename;
	declare string		sSeq     ;
	declare datetime_string	dtSessTime;
        declare integer iOff;

        dtSessTime= dcs_cgdc_get_datetime_param(DCS_CGDC_SESS_START_TIME);

        //
        // Correcao dcs_cgdc_filreg_get_init_file - Inicio
        // Aparentemente a funcao esta retornando o file id do arquivo derivado (ex.: *.0102) na versao 5.1
        // Na versao 4.0 era retornado o file id do master ou assembled (ex.: *.dat *.asm)
        // INTEC - Emanuel - 04/11/2009
        //
        //sFilename= dcs_cgdc_filreg_get_init_file(dcs_cgdc_get_string_param(DCS_CGDC_FILENAME));
        sFilename= dcs_cgdc_get_string_param(DCS_CGDC_FILENAME);

        //if ( PREFIX(SUFFIX(sFilename,8),1) == "."  )
        //{
        //      sSeq= PREFIX(SUFFIX(sFilename,14),6);
        //}
        //else
        //{
        //      sSeq= PREFIX(SUFFIX(sFilename,10),6);
        //}
        sSeq = "";
        iOff = 0;
        iSeq = 0;
        while (BYTE(sFilename, iOff) != 0 && BYTE(sFilename, iOff) != '.') iOff = iOff + 1; // last byte of string is zero, also checks if byte is '.'
        if (iOff > 0) sSeq = cgdc_suffix(cgdc_prefix(sFilename, iOff), 6);

        if (sSeq != "")
        {
                if ( cgdc_isdigits( sSeq ) == 1 )
                {
                        iSeq = sSeq;
                }
        }
        // Correcao dcs_cgdc_filreg_get_init_file - Fim
	
	iYear	= cgdc_substring(dtSessTime,2,2);
	
	if ( iYear > "15" ) 
	{	
		iYear= "15" ;
	}
	else
	{
		if ( iYear < "00" ) 
		{
			iYear= "00" ;
		}
	}
	
	iMonth	= cgdc_substring(dtSessTime,4,2);
	
	if ( iMonth > "12" ) 
	{
		iYear= "12" ;
	}
	else
	{
		if ( iMonth <= "00" ) 
		{
			iYear= "01" ;
		}
	}
	sOffset = FORMAT("%x%x%05x",iYear,iMonth,iSeq);
	cgdc_string_upper( sOffset ) ;

	return sOffset;
}

//******************************************************************************
//Procedure: InicializarVivoTabPortalCentral
//Objetivo:	Centralizar a inicializacao da tabela vivo_tab_portal_central
//
procedure InicializarVivoTabPortalCentral() returns integer
{
	if ( hdl_PortalCentral == MAP(0) )
	{
		//Inicializa tabela de Relacao Portal x Central
		hdl_PortalCentral = reference_open("vivo_tab_portal_central");
		if ( hdl_PortalCentral == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "%s|%s [%s:%d] Unable to open table [%s]",
					dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP),
					dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL),
					$scriptname, $linenumber, "vivo_tab_portal_central");
			DCS_RETURN_ABORT;
		}
		ALLOCATE (rec_PortalCentral);
		DCS_RETURN_OK;
	}
	DCS_RETURN_OK;
}//InicializarVivoTabPortalCentral

//******************************************************************************
//Procedure: GetCentralFromTabPortalCentral
//Objetivo:	Obter a central atraves do SYSTEM/PORTAL de entrada cadastrada
//na tabela vivo_tab_portal_central
//
procedure GetCentralFromTabPortalCentral() returns string
{
	if(InicializarVivoTabPortalCentral() == DCS_OPER_OK)
	{
		//Busca Regional na tabela de Relacao Portal x Central
		rec_PortalCentral.SYSTEM = dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP);
		rec_PortalCentral.PORTAL = dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL);
		if (reference_get (hdl_PortalCentral, rec_PortalCentral, CGDC_REFERENCE_EQUAL))
		{
			return rec_PortalCentral.COD_CCC;
		}
		else
		{
			cgdc_puterr("PORTALNCAD", "%s|%s [%s:%d] Portal nao cadastrado",
					dcs_cgdc_get_string_param(DCS_CGDC_INP_EXT_EQUIP),
					dcs_cgdc_get_string_param(DCS_CGDC_INP_DATA_PORTAL),
					$scriptname, $linenumber);
		}
	}

	return "";
}//GetCentralFromTabPortalCentral

// Walter Fonseca / Franklin Verissimo / TQI - Demanda 27422 inicio 
//--------------------------------------------------------------------------------------
// Procedimento: ConvertToKbytes
// Objetivo:     Converter em KBYTES os valores
//               com Medidas EV, BY, KB, MB, GB ou TB
// Retorno:      Valor em KBYTES
//--------------------------------------------------------------------------------------
procedure ConvertToKbytes
(
    string sValue,
    string sSizeUnit
) returns string
{
	declare string    sResult;
    declare unsigned long integer iKbytesValue; // estouro do campo integer
    
    iKbytesValue = TABLE ( sSizeUnit )
    {
		"EV", "EVENTO" => "100"; // Walter Fonseca - Chamado  20525185 inicio
		"BY"           => ( sValue / 1024 );
        "KB",""        => ( sValue ); // Walter Fonseca - Chamado 20525185 fim
        "MB"           => ( sValue * 1024 );
        "GB"           => ( ( sValue * 1024 ) * 1024 );
        "TB"           => ( ( ( sValue * 1024 ) * 1024 ) * 1024 );
    }                           
    
    sResult = cgdc_trim ( iKbytesValue , ' ' , 0 );
    sResult = cgdc_trim ( sResult , ' ' , CGDC_TRIM_RIGHT );           
	
    return sResult;
}
// Walter Fonseca/ Franklin Verissimo / TQI - Demanda 27422 fim

// Implementacao MVNO Demanda 94131 Inicio
//procedure lookupTipoContratoMvno
//(
//    string	sEot,
//	string	ref sTipoContratacao
//) returns integer
//{
//#define ROUTINE "lookupTipoContratoMvno"
//	
//	TRACE(CONCAT("lookupTipoContratoMvno\n"));
//	// Abre a tabela
//	declare integer iReturn;
//
//
//	// Abre a tabela
//	if ( hdlTipoContratoMvno == MAP(0) )
//	{
//		TRACE(CONCAT("Abre tabela\n"));
//		hdlTipoContratoMvno = reference_open("vivo_tab_tipo_contrato_mvno");
//		if ( hdlTipoContratoMvno == MAP(0) )
//		{
//			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
//					$scriptname, $linenumber, "vivo_tab_tipo_contrato_mvno");
//			DCS_RETURN_ABORT;
//		}
//
//		ALLOCATE (recTipoContratoMvno);
//	}
//	
//	CLEAR(recTipoContratoMvno);
//
//	// Seta Chave de busca
//	TRACE(CONCAT("sEot :",sEot,"\n"));
//	recTipoContratoMvno.COD_EOT = sEot;
//
//	
//
//	iReturn = reference_get(hdlTipoContratoMvno, recTipoContratoMvno, CGDC_REFERENCE_LTEQUAL);
//	if(iReturn == TRUE)
//	{
//
//		sTipoContratacao = recTipoContratoMvno.TIPO_CONTRATACAO;
//
//	}
//	return iReturn;
//
//#undef ROUTINE
//}
//
//
//procedure lookupMvnoAutorizada
//(
//    string	sEot,
//	string	sLac,
//	string	sDtChamada,
//	string	ref sValorMinimo,
//	integer	ref sFlagClone
//) returns integer
//{
//#define ROUTINE "lookupMvnoAutorizada"
//	declare integer iReturn; iReturn = FALSE;
//	declare integer iFlagLoop;
//	declare datetime_string		dtDtInicial;
//	declare datetime_string		dtDtFinal;
//	declare datetime_string		dtDtChamada;
//
//	if(cgdc_isdigits(sDtChamada) == FALSE )
//	{
//		return FALSE;
//	}
//	dtDtChamada	= sDtChamada;
//
//	
//	// Abre a tabela
//	if ( hdlMvnoAutorizada == MAP(0) )
//	{
//		hdlMvnoAutorizada = reference_open("vivo_tab_mvno_autorizada");
//		if ( hdlMvnoAutorizada == MAP(0) )
//		{
//			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
//					$scriptname, $linenumber, "vivo_tab_mvno_autoriza");
//			DCS_RETURN_ABORT;
//		}
//		ALLOCATE (recMvnoAutorizada);
//	}
//	
//	CLEAR(recMvnoAutorizada);
//	
//
//
//	// Seta Chave de busca
///*
//	recMvnoAutorizada.COD_EOT = sEot;
//	recMvnoAutorizada.LAC = sLac;
//	recMvnoAutorizada.DATA_ATIVACAO = sDtChamada;
//
//	iFlagLoop = reference_get(hdlMvnoAutorizada, recMvnoAutorizada, CGDC_REFERENCE_LTEQUAL);
//	while(iFlagLoop)
//	{
//		
//		dtDtInicial		= recMvnoAutorizada.DATA_ATIVACAO;
//		dtDtFinal		= recMvnoAutorizada.DATA_DESATIVACAO;
//		
//
//		if ( sEot == recMvnoAutorizada.COD_EOT  &&
//			 sLac == recMvnoAutorizada.LAC &&
//			(dtDtInicial <= dtDtChamada && dtDtChamada <= dtDtFinal) )
//		{
//			sValorMinimo = recMvnoAutorizada.VALOR_MINIMO;
//			sFlagClone = recMvnoAutorizada.FLAG_CLONE;
//			iReturn	= TRUE;
//			iFlagLoop = FALSE;
//
//		}
//		
//		if(iFlagLoop)
//		{	
//			iFlagLoop = reference_get(hdlMvnoAutorizada,recMvnoAutorizada,CGDC_REFERENCE_NEXT);
//			if(iFlagLoop != TRUE || sEot != recMvnoAutorizada.COD_EOT  ||
//			 sLac != recMvnoAutorizada.LAC)
//			{
//				iFlagLoop = FALSE;
//			}
//		}
//	}
//
//	return iReturn;
//*/
//#undef ROUTINE
//}
//--------------------------------------------------------------------
// Procedimento: GetCCCfromEOT
// Objetivo:     Obtem a CCC para a EOT
// Retorno:      TRUE/FALSE
//--------------------------------------------------------------------
procedure GetCCCfromEOT
(
    string sEOT
) returns string
{
		if ( hdl_vivo_tab_ccc_sms == MAP(0) )
		{
			hdl_vivo_tab_ccc_sms = reference_open("vivo_tab_ccc_sms");
			if ( hdl_vivo_tab_ccc_sms == MAP(0) )
			{
				cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
						$scriptname, $linenumber, "vivo_tab_mvno_autoriza");
				DCS_RETURN_ABORT;
			}

			ALLOCATE (rec_vivo_tab_ccc_sms);
		}
		
		CLEAR(rec_vivo_tab_ccc_sms);
        declare string sCCC;
        rec_vivo_tab_ccc_sms.EOT = sEOT;
        if ( reference_get( hdl_vivo_tab_ccc_sms,rec_vivo_tab_ccc_sms,CGDC_REFERENCE_EQUAL ) )
        {
                sCCC = rec_vivo_tab_ccc_sms.CCC;
                return sCCC;
        }
        return "";
}

//--------------------------------------------------------------------
// Procedimento: GetRotaVirtual
// Objetivo:     Obtem a Rota Virtual para a EOT
// Retorno:      TRUE/FALSE
//--------------------------------------------------------------------
procedure GetRotaVirtual 
( string sEOT ) 
returns string
{
	if ( hdl_rotas_virtuais == MAP(0) )
	{
		hdl_rotas_virtuais = reference_open("vivo_tab_rotas_virtuais");
		if ( hdl_rotas_virtuais == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_mvno_autoriza");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rec_rotas_virtuais);
	}
		
	CLEAR(rec_rotas_virtuais);
	rec_rotas_virtuais.EOT = sEOT;
	if( reference_get( hdl_rotas_virtuais,rec_rotas_virtuais,CGDC_REFERENCE_EQUAL ) )
	{
		return rec_rotas_virtuais.ROTA_VIRTUAL;
	}
	return "";
}
procedure getTabOperadorasNac
(
	string 		sEot,
	string ref	sUF,
	string ref	sTipoEot
)returns integer
{
	declare integer iReturne;
	sTipoEot = "";
	sUF = "";
	if ( hdl_operadoras_nac == MAP(0) )
	{
		hdl_operadoras_nac = reference_open("vivo_tab_operadoras_nac");
		if ( hdl_operadoras_nac == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_mvno_autoriza");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rec_operadoras_nac);
	}
	CLEAR(rec_operadoras_nac);
	rec_operadoras_nac.EOT = sEot;
	if ( reference_search ( hdl_operadoras_nac, rec_operadoras_nac ) )
	{
		iReturne = TRUE;
		sTipoEot = rec_operadoras_nac.TIPO_SMP;
		sUF = rec_operadoras_nac.UF;
	}
		
	return iReturne;
}

procedure getEotFromCnlAtlys
(
	string sCn
) returns string
{
	declare string sEot;
	
	sEot = "";
	if ( hdl_cnl_atlys == MAP(0) )
	{
		hdl_cnl_atlys = reference_open("vivo_tab_cnl_atlys");
		if ( hdl_cnl_atlys == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_mvno_autoriza");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rec_cnl_atlys);
	}
		
	CLEAR(rec_cnl_atlys);
	rec_cnl_atlys.CN = sCn;
	
	if ( reference_search ( hdl_cnl_atlys, rec_cnl_atlys ) )
	{
		sEot = rec_cnl_atlys.EOT;
	}

		
	return sEot;
}
procedure LookupVoidNull
(	string  		   	nada

) returns string
{
return "";
}
// Implementacao MVNO Demanda 94131 Fimï#«yA

/*******************************************************************************
Recupera os atributos da Oper Hold
returns:
	TRUE	- chave encontrada na tabela
	ABORT	- Alguma situacao inesperada na abertura da tabela
	FALSE	- Chave nao encontrada na tabela
*******************************************************************************/
procedure getTblOperHold
(
string			sEOT
) returns string
{
	declare string sHold;

	// Inicializacao de variaveis
	sHold = "";
	
	if ( hOperHold == MAP(0) )
	{
		hOperHold = reference_open("vivo_tab_oper_hold");
		if ( hOperHold == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_oper_hold");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rOperHold);
	}

	CLEAR(rOperHold,' ');

	rOperHold.EOT = sEOT;

	if (reference_get(hOperHold, rOperHold, CGDC_REFERENCE_EQUAL))
	{
		sHold = rOperHold.HOLD;
	}

	return sHold;
}

/*******************************************************************************
Recupera os atributos da Oper Hold - Tipo
returns:
	TRUE	- chave encontrada na tabela
	ABORT	- Alguma situacao inesperada na abertura da tabela
	FALSE	- Chave nao encontrada na tabela
*******************************************************************************/
procedure getTblOperTipo
(
string			sEOT
) returns string
{
	declare string	sTipo;

	sTipo = "";
	
	if ( hOperHold == MAP(0) )
	{
		hOperHold = reference_open("vivo_tab_oper_hold");
		if ( hOperHold == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_oper_hold");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rOperHold);
	}

	CLEAR(rOperHold,' ');

	rOperHold.EOT = sEOT;

	if (reference_get(hOperHold, rOperHold, CGDC_REFERENCE_EQUAL))
	{
		sTipo = rOperHold.TIPO;
	}

	return cgdc_substring(sTipo,2,1);
}

/*******************************************************************************
Retorna o cenario de Teste, uso exclusivo para teste
returns:
		Cenario
		Branco
*******************************************************************************/
procedure getTestCase
(
string			sFileName
) returns string
{
	declare string	sReturn;
	declare string	sTst;
	declare string	sInicio;
	declare string	sFim;
	declare string sAux;
	declare integer iSize;
	
	sReturn	= "";
	iSize = 0;

	// Inicializacao de variaveis
	sTst = "";
	sInicio = "";
	sFim = "";
	sAux = "";
	
	// Abre a tabela
	//OPEN_REFERENCE_TABLE("vivo_tab_oper_hold", hParam, rParam);

	if ( hParam == MAP(0) )
	{
		hParam = reference_open("vivo_tab_parametro");
		if ( hParam == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_parametro");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rParam);
	}

	CLEAR(rParam,' ');

	rParam.PARAMETRO = "TST_AMDOCS";

	if (reference_get(hParam, rParam, CGDC_REFERENCE_EQUAL))
	{
		
		sTst = rParam.VALOR;
		
	}
	
	if (sTst == "S")
	{
		rParam.PARAMETRO = "TST_AMDOCS_POS_INI";
		if (reference_get(hParam, rParam, CGDC_REFERENCE_EQUAL))
		{
		
			sInicio = rParam.VALOR;
		
		}
		
		rParam.PARAMETRO = "TST_AMDOCS_POS_FIM";
		if (reference_get(hParam, rParam, CGDC_REFERENCE_EQUAL))
		{
		
			sFim = rParam.VALOR;
		
		}
		
		if (sInicio != "" && sFim != "")
		{
			iSize = sFim - sInicio;
			sAux = PREFIX(sFileName,sFim);
			sReturn = SUFFIX(sAux, iSize);
		}
		
	}
	

	return sReturn;
}
/*******************************************************************************
Retorna o cenario de Teste, uso exclusivo para teste
returns:
		Cenario
		Branco
*******************************************************************************/
procedure getParameter
(
string			sParameter
) returns string
{

	if ( hParam == MAP(0) )
	{
		hParam = reference_open("vivo_tab_parametro");
		if ( hParam == MAP(0) )
		{
			cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_parametro");
			DCS_RETURN_ABORT;
		}

		ALLOCATE (rParam);
	}

	CLEAR(rParam,' ');

	rParam.PARAMETRO = sParameter;

	if (reference_get(hParam, rParam, CGDC_REFERENCE_EQUAL))
	{
		
		return rParam.VALOR;
		
	}

	return "";
}
procedure getEnvioEBT
(
    string sNumero,
    string sOperadora,
    record	"reference_table"		hdl_num_especiais,
    record	"vivo_tab_num_especiais_rec"	rec_num_especiais

) returns string
{
	// Acessar tabela de prefixos e servicos
	// Se for numero de emergencia, return "25";
	// Se for numero de atendimento ao cliente, return "26";
	// Se for numero especial, return "27";
	if ( prefix( sNumero,1 ) == "0" )
	{
		if ( ( sizeof( sNumero ) == 6 ) ||
		( sizeof( sNumero ) == 7 ) )
		{
			rec_num_especiais.NUMERO = cgdc_substring( sNumero,3,-1 );
			rec_num_especiais.OPERADORA = sOperadora;
			if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
			{
				return rec_num_especiais.ENVIO_EBT;
			}
			else
			{
				rec_num_especiais.OPERADORA = "";
				if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
				{
					return rec_num_especiais.ENVIO_EBT;
				}
			}
		}
		else if ( ( sizeof( sNumero ) == 8 ) ||
		          ( sizeof( sNumero ) == 9 ) )
		{
			rec_num_especiais.NUMERO = cgdc_substring( sNumero,5,-1 );
			rec_num_especiais.OPERADORA = sOperadora;
			if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
			{
				return rec_num_especiais.ENVIO_EBT;
			}
			else
			{
				rec_num_especiais.OPERADORA = "";
				if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
				{
					return rec_num_especiais.ENVIO_EBT;
				}
			}
		}
	}
	else if ( ( prefix( sNumero,1 ) == "#" ) ||
	          ( prefix( sNumero,1 ) == "*" ) )
	{
		if ( sizeof( sNumero ) <= 5 )
		{
			rec_num_especiais.NUMERO = sNumero;
			rec_num_especiais.OPERADORA = sOperadora;
			if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
			{
				return rec_num_especiais.ENVIO_EBT;
			}
			else
			{
				rec_num_especiais.OPERADORA = "";
				if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
				{
					return rec_num_especiais.ENVIO_EBT;
				}
			}
		}
		else
		{
			// Identifica se tem mais que 1 caractere especial
			declare integer iPos;
			declare string sChar;
			iPos = 1;
			while ( iPos < sizeof( sNumero ) )
			{
				sChar = cgdc_substring( sNumero,iPos,1 );
				if ( sChar != "*" && sChar != "#" )
				{
					break;
				}
				iPos = iPos + 1;
			}

			if ( ( sChar == "*" ) ||
			        ( sChar == "#" ) )
			{
				rec_num_especiais.NUMERO = prefix( sNumero,iPos+1 );
				rec_num_especiais.OPERADORA = sOperadora;
				if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
				{
					return rec_num_especiais.ENVIO_EBT;
				}
				else
				{
					rec_num_especiais.OPERADORA = "";
					if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
					{
						return rec_num_especiais.ENVIO_EBT;
					}
				}
			}
			else
			{
				declare integer iTamanho;
				iTamanho = 3;

				while ( iTamanho <= 5 )
				{
					rec_num_especiais.NUMERO = prefix( sNumero,iTamanho );
					rec_num_especiais.OPERADORA = sOperadora;
					if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
					{
						return rec_num_especiais.ENVIO_EBT;
					}
					else
					{
						rec_num_especiais.OPERADORA = "";
						if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
						{
							return rec_num_especiais.ENVIO_EBT;
						}
						else
						{
							iTamanho = iTamanho + 1;
						}
					}
				}
			}
		}
	}
	else if ( prefix( sNumero,1 ) == "1" )
	{
		rec_num_especiais.NUMERO = sNumero;
		rec_num_especiais.OPERADORA = sOperadora;
		if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
		{
			return rec_num_especiais.ENVIO_EBT;
		}
		else
		{
			rec_num_especiais.OPERADORA = "";
			if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
			{
				return rec_num_especiais.ENVIO_EBT;
			}
		}
	}
	else
	{
		if ( sizeof( sNumero ) <= 5 )
		{
			rec_num_especiais.NUMERO = sNumero;
			rec_num_especiais.OPERADORA = sOperadora;
			if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
			{
				return rec_num_especiais.ENVIO_EBT;
			}
			else
			{
				rec_num_especiais.OPERADORA = "";
				if ( reference_search( hdl_num_especiais,rec_num_especiais ) )
				{
					return rec_num_especiais.ENVIO_EBT;
				}
			}
		}
	}
	return "  ";
}


//--------------------------------------------------------------------
// Procedimento: VerificaSelCDRCenario
// Objetivo:     Pesquisa na Tabela de Separação de Cenários
// Retorno:      True ou False
//--------------------------------------------------------------------
procedure VerificaSelCDRCenario
(
    string  sNum,
	string	sData
)   returns integer
{
    declare integer iStatus;
	declare datetime_string	dtDataSistema;
	declare string sDataEvento;
	
    iStatus     = 0;
	
	dtDataSistema = cgdc_get_local_time();
	sDataEvento = PREFIX(dtDataSistema, 14);
	
	//----------------------------------------------------------------------
	//Inicializa tabela de Separacao de Cenarios
	hdl_SepCDRCenario = reference_open("vivo_tab_sep_cdr_cenario");
	if ( hdl_SepCDRCenario == MAP(0) )
	{
		cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
					$scriptname, $linenumber, "vivo_tab_parametro");
			DCS_RETURN_ABORT;
	}
	ALLOCATE (rec_SepCDRCenario);

	// Verifica se algum dos assinantes do CDR está presente na tabela de cenários
	
	rec_SepCDRCenario.ASSINANTE = cgdc_trim( sNum,' ',CGDC_TRIM_RIGHT);
	
	iStatus = reference_get (hdl_SepCDRCenario, rec_SepCDRCenario, CGDC_REFERENCE_EQUAL);
	
	TRACE(CONCAT("sNum: ", sNum,"\n"));
	//TRACE(CONCAT("sData: ", sData,"\n"));
	TRACE(CONCAT("rec_SepCDRCenario.ASSINANTE: ", rec_SepCDRCenario.ASSINANTE,"\n"));	
	TRACE(CONCAT("rec_SepCDRCenario.DT_INICIO: ", rec_SepCDRCenario.DT_INICIO,"\n"));
	TRACE(CONCAT("rec_SepCDRCenario.DT_FIM: ", rec_SepCDRCenario.DT_FIM,"\n"));
	
	if ( iStatus )
	{
		if ( ( rec_SepCDRCenario.ASSINANTE == sNum ) && (rec_SepCDRCenario.DT_INICIO <= sDataEvento) && (rec_SepCDRCenario.DT_FIM >= sData) )
		{
			return 1;
		}
	}
	
    return 0;
}

//--------------------------------------------------------------------
// Procedimento: VerificaSelCDRCenario2
// Objetivo:     Pesquisa na Tabela de Separacao de Cenarios
// Retorno:      True ou False
//--------------------------------------------------------------------
procedure VerificaSelCDRCenario2
(
    string  sNum,
	string	sData,
	record	"reference_table"				hdl_SepCDRCenario,
    record	"vivo_tab_sep_cdr_cenario_rec"	rec_SepCDRCenario
)   returns integer
{
    declare integer iStatus;
	declare datetime_string	dtDataSistema;
	declare string sDataEvento;
	
    iStatus     = 0;
	
	dtDataSistema = cgdc_get_local_time();
	sDataEvento = PREFIX(dtDataSistema, 14);
	
	// Verifica se algum dos assinantes do CDR estao presente na tabela de cenarios
	
	rec_SepCDRCenario.ASSINANTE = cgdc_trim( sNum,' ',CGDC_TRIM_RIGHT);
	
	iStatus = reference_get (hdl_SepCDRCenario, rec_SepCDRCenario, CGDC_REFERENCE_EQUAL);
	
	if ( iStatus )
	{
		if ( ( rec_SepCDRCenario.ASSINANTE == sNum ) && (rec_SepCDRCenario.DT_INICIO <= sDataEvento) && (rec_SepCDRCenario.DT_FIM >= sData) )
		{
			return 1;
		}
	}
	
    return 0;
}

//--------------------------------------------------------------------
// Procedimento: getTblMigracao
// Objetivo:     Pesquisa na Tabela de Separação de Cenários
// Retorno:      True ou False
//--------------------------------------------------------------------
procedure getTblMigracao
(
    string sCN_TERMINAL,
	string sDataEvento,
	record "reference_table"			hMigcli,
	record "vivo_tab_migracao_rec_tbl"	rMigcli,
	string ref	sDATA_INICIO,
	string ref	sDATA_FIM,
	string ref	sDATA_MIGRACAO,
	string ref	sSTATUS_MIGRACAO,
	string ref	sBILLING,
	string ref	sACAO,
	string ref	sLOTE
)   returns integer
{
    declare integer iStatus;
	declare datetime_string	dtDataSistema;
	declare string sDataSistema;
	
    iStatus = 0;
	
	dtDataSistema = cgdc_get_local_time();
	sDataSistema = PREFIX(dtDataSistema, 14);
	
	rMigcli.CN_TERMINAL = sCN_TERMINAL;

	// Verifica se o assinante do CDR está presente na tabela de migracao
	iStatus = reference_get (hMigcli, rMigcli, CGDC_REFERENCE_EQUAL);
	
	if ( iStatus )
	{
		if ( ( rMigcli.CN_TERMINAL == sCN_TERMINAL ) && (sDataSistema >= rMigcli.DATA_MIGRACAO ) )
		{
			sDATA_INICIO		= rMigcli.DATA_INICIO;
			sDATA_FIM			= rMigcli.DATA_FIM;
			sDATA_MIGRACAO		= rMigcli.DATA_MIGRACAO;
			sSTATUS_MIGRACAO	= rMigcli.STATUS_MIGRACAO;
			sBILLING			= rMigcli.BILLING;
			sACAO				= rMigcli.ACAO;
			sLOTE				= rMigcli.LOTE;
			
			return 1;
		}
	}
	
    return 0;
}

//--------------------------------------------------------------------
// Procedimento: GetDeParaIdGoogle
// Objetivo:     Pesquisa na Tabela 'vivo_tab_depara_id_rcs'
// Retorno:      True ou False
//--------------------------------------------------------------------
procedure GetDeParaIdGoogle
(
string        sId_Google,
string        sDt_Ativacao,
string        ref sMSISDN
) returns integer
{
    if ( hId_Rcs == MAP(0) )
    {
        hId_Rcs = reference_open("vivo_tab_depara_id_rcs");
        if ( hId_Rcs == MAP(0) )
        {
            cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
                    $scriptname, $linenumber, "vivo_tab_depara_id_rcs");
            DCS_RETURN_ABORT;
        }

        ALLOCATE (rId_Rcs);
    }

    CLEAR(rId_Rcs,' ');

    rId_Rcs.ID_GOOGLE = sId_Google;
    rId_Rcs.DATA_ATIVACAO = sDt_Ativacao;

    if (reference_get(hId_Rcs, rId_Rcs, CGDC_REFERENCE_LTEQUAL))
    {
        if(  sId_Google == rId_Rcs.ID_GOOGLE && rId_Rcs.DATA_ATIVACAO <= sDt_Ativacao)
        {
            sMSISDN = rId_Rcs.MSISDN;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    return FALSE;
}

//--------------------------------------------------------------------
// Procedimento: GetDeParaNumBRcs
// Objetivo:     Pesquisa na Tabela 'vivo_tab_depara_numb_rcs'
// Retorno:      True ou False
//--------------------------------------------------------------------
procedure GetDeParaNumBRcs
(
string          sId_Google,
string          ref sNumeroB
) returns integer
{
    if ( hId_NumBRcs == MAP(0) )
    {
        hId_NumBRcs = reference_open("vivo_tab_depara_numb_rcs");
        if ( hId_NumBRcs == MAP(0) )
        {
            cgdc_puterr("OPEN_TBL", "[%s:%d] Unable to open table [%s]",
                    $scriptname, $linenumber, "vivo_tab_depara_numb_rcs");
            DCS_RETURN_ABORT;
        }

        ALLOCATE (rId_NumBRcs);
    }

    CLEAR(rId_NumBRcs,' ');

    rId_NumBRcs.ID_GOOGLE = sId_Google;

    if (reference_get(hId_NumBRcs, rId_NumBRcs, CGDC_REFERENCE_EQUAL))
    {
        sNumeroB = rId_NumBRcs.NUMERO_B;
        return TRUE;
    }

    return FALSE;
}
//--------------------------------------------------------------------
// Procedimento: getEotMigNextelClaro
// Objetivo:     De para da Nextel Para Claro
// Retorno:      True ou False
//--------------------------------------------------------------------
procedure getEotMigNextelClaro 
(
string   sNumero,
string 	 sEotDe,
string ref	sEotPara
)returns integer
{
    declare string sValor;
    declare string sCn;
    sEotPara = "";
    sValor = getParameter("FLAG_MIG_NEXTEL_CLARO");
    if(sValor == "")
    {
        return 0;
    }
    else if(sValor != "S")
    {
        return 0;
    }
    else if(sValor == "S")
    {
       //Regra 1 
       if(sEotDe == "823" && sNumero != "ROTAS")
       {
           sCn = PREFIX(sNumero,2);
           if(sCn == "11")
           {
               sEotPara = "014";
               return 1;
           }
           else if(sCn == "12" || sCn == "13" || sCn == "14" || sCn == "15" || sCn == "16" || sCn == "17" || sCn == "18" || sCn == "19")
           {
               sEotPara = "017";
               return 1; 
           }
       }
       else
       {
           //Regra 2
           sEotPara = TABLE(sEotDe)
           {
               "837" =>    "006"  
                {
                    return 1;
                }
                "823" =>	"014"
                {
                    return 1;
                }
                "823" =>	"017"
                {
                    return 1;
                }
                "824" =>	"018"
                {
                    return 1;
                }
                "825" =>	"019"
                {
                    return 1;
                }
                "853" =>	"022"
                {
                    return 1;
                }
                "850" =>	"023"
                {
                    return 1;
                }
                "854" =>	"024"
                {
                    return 1;
                }
                "857" =>	"028"
                {
                    return 1;
                }
                "855" =>	"029"
                {
                    return 1;
                }
                "856" =>	"032"
                {
                    return 1;
                }
                "844" =>	"054"
                {
                    return 1;
                }
                "843" =>	"057"
                {
                    return 1;
                }
                "846" =>	"058"
                {
                    return 1;
                }
                "845" =>	"059"
                {
                    return 1;
                }
                "838" =>	"063"
                {
                    return 1;
                }
                "839" =>	"069"
                {
                    return 1;
                }
                "840" =>	"077"
                {
                    return 1;
                }
                "826" =>	"430"
                {
                    return 1;
                }
                "827" =>	"441"
                {
                    return 1;
                }
                "828" =>	"447"
                {
                    return 1;
                }
                "847" =>	"471"
                {
                    return 1;
                }
                "849" =>	"479"
                {
                    return 1;
                }
                "893" =>	"490"
                {
                    return 1;
                }
                "859" => "493"
                {
                    return 1;
                }
                "858" =>	"494"
                {
                    return 1;
                }
                "860" =>	"497"
                {
                    return 1;
                }
                "894" =>	"499"
                {
                    return 1;
                }
                default	=> "";
           }; 
           return 0;
       }
      
    }
}